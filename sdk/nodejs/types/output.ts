// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import * as utilities from "../utilities";

export interface AlertChannelCall {
    /**
     * The name of this alert channel
     */
    name: string;
    /**
     * The mobile number to receive the alerts
     */
    number: string;
}

export interface AlertChannelEmail {
    /**
     * The email address of this email alert channel.
     */
    address: string;
}

export interface AlertChannelOpsgenie {
    apiKey: string;
    name: string;
    priority: string;
    region: string;
}

export interface AlertChannelPagerduty {
    account?: string;
    serviceKey: string;
    serviceName?: string;
}

export interface AlertChannelSlack {
    /**
     * The name of the alert's Slack channel
     */
    channel: string;
    /**
     * The Slack webhook URL
     */
    url: string;
}

export interface AlertChannelSms {
    /**
     * The name of this alert channel
     */
    name: string;
    /**
     * The mobile number to receive the alerts
     */
    number: string;
}

export interface AlertChannelWebhook {
    headers: {[key: string]: string};
    /**
     * (Default `POST`)
     */
    method?: string;
    name: string;
    queryParameters: {[key: string]: string};
    template?: string;
    url: string;
    webhookSecret?: string;
    /**
     * Type of the webhook. Possible values are 'WEBHOOK*DISCORD', 'WEBHOOK*FIREHYDRANT', 'WEBHOOK*GITLAB*ALERT', 'WEBHOOK*SPIKESH', 'WEBHOOK*SPLUNK', 'WEBHOOK*MSTEAMS' and 'WEBHOOK*TELEGRAM'.
     */
    webhookType?: string;
}

export interface CheckAlertChannelSubscription {
    activated: boolean;
    channelId: number;
}

export interface CheckAlertSettings {
    /**
     * Determines the type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`. (Default `RUN_BASED`).
     */
    escalationType?: string;
    /**
     * Configuration for parallel run failure threshold.
     */
    parallelRunFailureThresholds: outputs.CheckAlertSettingsParallelRunFailureThreshold[];
    /**
     * Defines how often to send reminder notifications after initial alert.
     */
    reminders: outputs.CheckAlertSettingsReminder[];
    /**
     * Configuration for run-based escalation.
     */
    runBasedEscalations: outputs.CheckAlertSettingsRunBasedEscalation[];
    /**
     * @deprecated This legacy attribute is no longer available and even if set, does not affect behavior. It will be removed in the next major version.
     */
    sslCertificates?: outputs.CheckAlertSettingsSslCertificate[];
    /**
     * Configuration for time-based escalation.
     */
    timeBasedEscalations: outputs.CheckAlertSettingsTimeBasedEscalation[];
}

export interface CheckAlertSettingsParallelRunFailureThreshold {
    /**
     * Whether parallel run failure threshold is enabled. Only applies if the check is scheduled for multiple locations in parallel. (Default `false`).
     */
    enabled?: boolean;
    /**
     * Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
     */
    percentage?: number;
}

export interface CheckAlertSettingsReminder {
    /**
     * Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
     */
    amount?: number;
    /**
     * Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    interval?: number;
}

export interface CheckAlertSettingsRunBasedEscalation {
    /**
     * Send an alert notification after the given number of consecutive check runs have failed. Possible values are between `1` and `5`. (Default `1`).
     */
    failedRunThreshold?: number;
}

export interface CheckAlertSettingsSslCertificate {
    /**
     * No longer available.
     */
    alertThreshold?: number;
    /**
     * No longer available.
     */
    enabled?: boolean;
}

export interface CheckAlertSettingsTimeBasedEscalation {
    /**
     * Send an alert notification after the check has been failing for the given amount of time (in minutes). Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    minutesFailingThreshold?: number;
}

export interface CheckEnvironmentVariable {
    key: string;
    locked?: boolean;
    secret?: boolean;
    value: string;
}

export interface CheckGroupAlertChannelSubscription {
    activated: boolean;
    channelId: number;
}

export interface CheckGroupAlertSettings {
    /**
     * Determines the type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`. (Default `RUN_BASED`).
     */
    escalationType?: string;
    /**
     * Configuration for parallel run failure threshold.
     */
    parallelRunFailureThresholds: outputs.CheckGroupAlertSettingsParallelRunFailureThreshold[];
    /**
     * Defines how often to send reminder notifications after initial alert.
     */
    reminders: outputs.CheckGroupAlertSettingsReminder[];
    /**
     * Configuration for run-based escalation.
     */
    runBasedEscalations: outputs.CheckGroupAlertSettingsRunBasedEscalation[];
    /**
     * @deprecated This legacy attribute is no longer available and even if set, does not affect behavior. It will be removed in the next major version.
     */
    sslCertificates?: outputs.CheckGroupAlertSettingsSslCertificate[];
    /**
     * Configuration for time-based escalation.
     */
    timeBasedEscalations: outputs.CheckGroupAlertSettingsTimeBasedEscalation[];
}

export interface CheckGroupAlertSettingsParallelRunFailureThreshold {
    /**
     * Whether parallel run failure threshold is enabled. Only applies if the check is scheduled for multiple locations in parallel. (Default `false`).
     */
    enabled?: boolean;
    /**
     * Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
     */
    percentage?: number;
}

export interface CheckGroupAlertSettingsReminder {
    /**
     * Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
     */
    amount?: number;
    /**
     * Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    interval?: number;
}

export interface CheckGroupAlertSettingsRunBasedEscalation {
    /**
     * Send an alert notification after the given number of consecutive check runs have failed. Possible values are between `1` and `5`. (Default `1`).
     */
    failedRunThreshold?: number;
}

export interface CheckGroupAlertSettingsSslCertificate {
    /**
     * No longer available.
     */
    alertThreshold?: number;
    /**
     * No longer available.
     */
    enabled?: boolean;
}

export interface CheckGroupAlertSettingsTimeBasedEscalation {
    /**
     * Send an alert notification after the check has been failing for the given amount of time (in minutes). Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    minutesFailingThreshold?: number;
}

export interface CheckGroupApiCheckDefaults {
    assertions?: outputs.CheckGroupApiCheckDefaultsAssertion[];
    basicAuth: outputs.CheckGroupApiCheckDefaultsBasicAuth;
    headers: {[key: string]: string};
    queryParameters: {[key: string]: string};
    /**
     * The base url for this group which you can reference with the `GROUP_BASE_URL` variable in all group checks.
     */
    url: string;
}
/**
 * checkGroupApiCheckDefaultsProvideDefaults sets the appropriate defaults for CheckGroupApiCheckDefaults
 */
export function checkGroupApiCheckDefaultsProvideDefaults(val: CheckGroupApiCheckDefaults): CheckGroupApiCheckDefaults {
    return {
        ...val,
        url: (val.url) ?? "",
    };
}

export interface CheckGroupApiCheckDefaultsAssertion {
    /**
     * The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
     */
    comparison: string;
    property?: string;
    /**
     * The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
     */
    source: string;
    target: string;
}

export interface CheckGroupApiCheckDefaultsBasicAuth {
    password: string;
    username: string;
}

export interface CheckGroupEnvironmentVariable {
    key: string;
    locked?: boolean;
    secret?: boolean;
    value: string;
}

export interface CheckGroupRetryStrategy {
    /**
     * The number of seconds to wait before the first retry attempt. (Default `60`).
     */
    baseBackoffSeconds?: number;
    /**
     * The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
     */
    maxDurationSeconds?: number;
    /**
     * The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
     */
    maxRetries?: number;
    /**
     * Apply the retry strategy only if the defined conditions match.
     */
    onlyOn?: outputs.CheckGroupRetryStrategyOnlyOn;
    /**
     * Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
     */
    sameRegion?: boolean;
    /**
     * Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
     */
    type: string;
}

export interface CheckGroupRetryStrategyOnlyOn {
    /**
     * When `true`, retry only if the cause of the failure is a network error. (Default `false`).
     */
    networkError?: boolean;
}

export interface CheckRequest {
    /**
     * A request can have multiple assertions.
     */
    assertions?: outputs.CheckRequestAssertion[];
    /**
     * Set up HTTP basic authentication (username & password).
     */
    basicAuth: outputs.CheckRequestBasicAuth;
    /**
     * The body of the request.
     */
    body?: string;
    /**
     * The `Content-Type` header of the request. Possible values `NONE`, `JSON`, `FORM`, `RAW`, and `GRAPHQL`.
     */
    bodyType?: string;
    followRedirects?: boolean;
    headers: {[key: string]: string};
    /**
     * IP Family to be used when executing the api check. The value can be either IPv4 or IPv6.
     */
    ipFamily?: string;
    /**
     * The HTTP method to use for this API check. Possible values are `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`. (Default `GET`).
     */
    method?: string;
    queryParameters: {[key: string]: string};
    skipSsl?: boolean;
    url: string;
}

export interface CheckRequestAssertion {
    /**
     * The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
     */
    comparison: string;
    property?: string;
    /**
     * The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
     */
    source: string;
    target?: string;
}

export interface CheckRequestBasicAuth {
    password: string;
    username: string;
}

export interface CheckRetryStrategy {
    /**
     * The number of seconds to wait before the first retry attempt. (Default `60`).
     */
    baseBackoffSeconds?: number;
    /**
     * The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
     */
    maxDurationSeconds?: number;
    /**
     * The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
     */
    maxRetries?: number;
    /**
     * Apply the retry strategy only if the defined conditions match.
     */
    onlyOn?: outputs.CheckRetryStrategyOnlyOn;
    /**
     * Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
     */
    sameRegion?: boolean;
    /**
     * Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
     */
    type: string;
}

export interface CheckRetryStrategyOnlyOn {
    /**
     * When `true`, retry only if the cause of the failure is a network error. (Default `false`).
     */
    networkError?: boolean;
}

export interface CheckTriggerIncident {
    /**
     * A detailed description of the incident.
     */
    description: string;
    /**
     * The name of the incident.
     */
    name: string;
    /**
     * Whether to notify subscribers when the incident is triggered.
     */
    notifySubscribers: boolean;
    /**
     * The status page service that this incident will be associated with.
     */
    serviceId: string;
    /**
     * The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
     */
    severity: string;
}

export interface DnsMonitorAlertChannelSubscription {
    /**
     * Whether an alert should be sent to this channel.
     */
    activated: boolean;
    /**
     * The ID of the alert channel.
     */
    channelId: number;
}

export interface DnsMonitorAlertSettings {
    /**
     * Determines the type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`. (Default `RUN_BASED`).
     */
    escalationType?: string;
    /**
     * Configuration for parallel run failure threshold.
     */
    parallelRunFailureThresholds: outputs.DnsMonitorAlertSettingsParallelRunFailureThreshold[];
    /**
     * Defines how often to send reminder notifications after initial alert.
     */
    reminders: outputs.DnsMonitorAlertSettingsReminder[];
    /**
     * Configuration for run-based escalation.
     */
    runBasedEscalations: outputs.DnsMonitorAlertSettingsRunBasedEscalation[];
    /**
     * Configuration for time-based escalation.
     */
    timeBasedEscalations: outputs.DnsMonitorAlertSettingsTimeBasedEscalation[];
}

export interface DnsMonitorAlertSettingsParallelRunFailureThreshold {
    /**
     * Whether parallel run failure threshold is enabled. Only applies if the monitor is scheduled for multiple locations in parallel. (Default `false`).
     */
    enabled?: boolean;
    /**
     * Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
     */
    percentage?: number;
}

export interface DnsMonitorAlertSettingsReminder {
    /**
     * Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
     */
    amount?: number;
    /**
     * Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    interval?: number;
}

export interface DnsMonitorAlertSettingsRunBasedEscalation {
    /**
     * Send an alert notification after the given number of consecutive monitor runs have failed. Possible values are between `1` and `5`. (Default `1`).
     */
    failedRunThreshold?: number;
}

export interface DnsMonitorAlertSettingsTimeBasedEscalation {
    /**
     * Send an alert notification after the monitor has been failing for the given amount of time (in minutes). Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    minutesFailingThreshold?: number;
}

export interface DnsMonitorRequest {
    /**
     * Assertions to validate the HTTP response. DNS monitors only support status code assertions.
     */
    assertions?: outputs.DnsMonitorRequestAssertion[];
    /**
     * The name server to use.
     */
    nameServer?: outputs.DnsMonitorRequestNameServer;
    /**
     * The protocol used to communicate with the name server. Possible values are `UDP` and `TCP`. (Default `UDP`).
     */
    protocol?: string;
    /**
     * The DNS record to query.
     */
    query: string;
    /**
     * The DNS record type. Possible values are `A`, `AAAA`, `CNAME`, `MX`, `NS`, `TXT` and `SOA`.
     */
    recordType: string;
}

export interface DnsMonitorRequestAssertion {
    /**
     * The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `GREATER_THAN` and `LESS_THAN`.
     */
    comparison: string;
    property?: string;
    /**
     * The source of the asserted value. Possible values are `RESPONSE_CODE`, `RESPONSE_TIME`, `TEXT_ANSWER` and `JSON_ANSWER`.
     */
    source: string;
    /**
     * The target value. Typically `NOERROR` when the source is `RESPONSE_CODE`.
     */
    target: string;
}

export interface DnsMonitorRequestNameServer {
    /**
     * The name server host.
     */
    host?: string;
    /**
     * The name server port.
     */
    port?: number;
}

export interface DnsMonitorRetryStrategy {
    /**
     * The number of seconds to wait before the first retry attempt. (Default `60`).
     */
    baseBackoffSeconds?: number;
    /**
     * The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
     */
    maxDurationSeconds?: number;
    /**
     * The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
     */
    maxRetries?: number;
    /**
     * Apply the retry strategy only if the defined conditions match.
     */
    onlyOn?: outputs.DnsMonitorRetryStrategyOnlyOn;
    /**
     * Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
     */
    sameRegion?: boolean;
    /**
     * Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
     */
    type: string;
}

export interface DnsMonitorRetryStrategyOnlyOn {
    /**
     * When `true`, retry only if the cause of the failure is a network error. (Default `false`).
     */
    networkError?: boolean;
}

export interface DnsMonitorTriggerIncident {
    /**
     * A detailed description of the incident.
     */
    description: string;
    /**
     * The name of the incident.
     */
    name: string;
    /**
     * Whether to notify subscribers when the incident is triggered.
     */
    notifySubscribers: boolean;
    /**
     * The status page service that this incident will be associated with.
     */
    serviceId: string;
    /**
     * The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
     */
    severity: string;
}

export interface HeartbeatCheckAlertChannelSubscription {
    activated: boolean;
    channelId: number;
}

export interface HeartbeatCheckAlertSettings {
    /**
     * Determines the type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`. (Default `RUN_BASED`).
     */
    escalationType?: string;
    /**
     * Configuration for parallel run failure threshold.
     */
    parallelRunFailureThresholds: outputs.HeartbeatCheckAlertSettingsParallelRunFailureThreshold[];
    /**
     * Defines how often to send reminder notifications after initial alert.
     */
    reminders: outputs.HeartbeatCheckAlertSettingsReminder[];
    /**
     * Configuration for run-based escalation.
     */
    runBasedEscalations: outputs.HeartbeatCheckAlertSettingsRunBasedEscalation[];
    /**
     * @deprecated This legacy attribute is no longer available and even if set, does not affect behavior. It will be removed in the next major version.
     */
    sslCertificates?: outputs.HeartbeatCheckAlertSettingsSslCertificate[];
    /**
     * Configuration for time-based escalation.
     */
    timeBasedEscalations: outputs.HeartbeatCheckAlertSettingsTimeBasedEscalation[];
}

export interface HeartbeatCheckAlertSettingsParallelRunFailureThreshold {
    /**
     * Whether parallel run failure threshold is enabled. Only applies if the monitor is scheduled for multiple locations in parallel. (Default `false`).
     */
    enabled?: boolean;
    /**
     * Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
     */
    percentage?: number;
}

export interface HeartbeatCheckAlertSettingsReminder {
    /**
     * Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
     */
    amount?: number;
    /**
     * Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    interval?: number;
}

export interface HeartbeatCheckAlertSettingsRunBasedEscalation {
    /**
     * Send an alert notification after the given number of consecutive monitor runs have failed. Possible values are between `1` and `5`. (Default `1`).
     */
    failedRunThreshold?: number;
}

export interface HeartbeatCheckAlertSettingsSslCertificate {
    /**
     * No longer available.
     */
    alertThreshold?: number;
    /**
     * No longer available.
     */
    enabled?: boolean;
}

export interface HeartbeatCheckAlertSettingsTimeBasedEscalation {
    /**
     * Send an alert notification after the monitor has been failing for the given amount of time (in minutes). Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    minutesFailingThreshold?: number;
}

export interface HeartbeatCheckHeartbeat {
    /**
     * How long Checkly should wait before triggering any alerts when a ping does not arrive within the set period.
     */
    grace: number;
    /**
     * Possible values `seconds`, `minutes`, `hours` and `days`.
     */
    graceUnit: string;
    /**
     * How often you expect a ping to the ping URL.
     */
    period: number;
    /**
     * Possible values `seconds`, `minutes`, `hours` and `days`.
     */
    periodUnit: string;
    /**
     * Custom token to generate your ping URL. Checkly will expect a ping to `https://ping.checklyhq.com/[PING_TOKEN]`.
     */
    pingToken: string;
}

export interface HeartbeatCheckTriggerIncident {
    /**
     * A detailed description of the incident.
     */
    description: string;
    /**
     * The name of the incident.
     */
    name: string;
    /**
     * Whether to notify subscribers when the incident is triggered.
     */
    notifySubscribers: boolean;
    /**
     * The status page service that this incident will be associated with.
     */
    serviceId: string;
    /**
     * The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
     */
    severity: string;
}

export interface HeartbeatMonitorAlertChannelSubscription {
    activated: boolean;
    channelId: number;
}

export interface HeartbeatMonitorAlertSettings {
    /**
     * Determines the type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`. (Default `RUN_BASED`).
     */
    escalationType?: string;
    /**
     * Configuration for parallel run failure threshold.
     */
    parallelRunFailureThresholds: outputs.HeartbeatMonitorAlertSettingsParallelRunFailureThreshold[];
    /**
     * Defines how often to send reminder notifications after initial alert.
     */
    reminders: outputs.HeartbeatMonitorAlertSettingsReminder[];
    /**
     * Configuration for run-based escalation.
     */
    runBasedEscalations: outputs.HeartbeatMonitorAlertSettingsRunBasedEscalation[];
    /**
     * @deprecated This legacy attribute is no longer available and even if set, does not affect behavior. It will be removed in the next major version.
     */
    sslCertificates?: outputs.HeartbeatMonitorAlertSettingsSslCertificate[];
    /**
     * Configuration for time-based escalation.
     */
    timeBasedEscalations: outputs.HeartbeatMonitorAlertSettingsTimeBasedEscalation[];
}

export interface HeartbeatMonitorAlertSettingsParallelRunFailureThreshold {
    /**
     * Whether parallel run failure threshold is enabled. Only applies if the monitor is scheduled for multiple locations in parallel. (Default `false`).
     */
    enabled?: boolean;
    /**
     * Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
     */
    percentage?: number;
}

export interface HeartbeatMonitorAlertSettingsReminder {
    /**
     * Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
     */
    amount?: number;
    /**
     * Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    interval?: number;
}

export interface HeartbeatMonitorAlertSettingsRunBasedEscalation {
    /**
     * Send an alert notification after the given number of consecutive monitor runs have failed. Possible values are between `1` and `5`. (Default `1`).
     */
    failedRunThreshold?: number;
}

export interface HeartbeatMonitorAlertSettingsSslCertificate {
    /**
     * No longer available.
     */
    alertThreshold?: number;
    /**
     * No longer available.
     */
    enabled?: boolean;
}

export interface HeartbeatMonitorAlertSettingsTimeBasedEscalation {
    /**
     * Send an alert notification after the monitor has been failing for the given amount of time (in minutes). Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    minutesFailingThreshold?: number;
}

export interface HeartbeatMonitorHeartbeat {
    /**
     * How long Checkly should wait before triggering any alerts when a ping does not arrive within the set period.
     */
    grace: number;
    /**
     * Possible values `seconds`, `minutes`, `hours` and `days`.
     */
    graceUnit: string;
    /**
     * How often you expect a ping to the ping URL.
     */
    period: number;
    /**
     * Possible values `seconds`, `minutes`, `hours` and `days`.
     */
    periodUnit: string;
    /**
     * Custom token to generate your ping URL. Checkly will expect a ping to `https://ping.checklyhq.com/[PING_TOKEN]`.
     */
    pingToken: string;
}

export interface HeartbeatMonitorTriggerIncident {
    /**
     * A detailed description of the incident.
     */
    description: string;
    /**
     * The name of the incident.
     */
    name: string;
    /**
     * Whether to notify subscribers when the incident is triggered.
     */
    notifySubscribers: boolean;
    /**
     * The status page service that this incident will be associated with.
     */
    serviceId: string;
    /**
     * The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
     */
    severity: string;
}

export interface StatusPageCard {
    /**
     * The name of the card.
     */
    name: string;
    /**
     * A list of services to attach to the card.
     */
    serviceAttachments: outputs.StatusPageCardServiceAttachment[];
}

export interface StatusPageCardServiceAttachment {
    /**
     * The ID of the service.
     */
    serviceId: string;
}

export interface TcpCheckAlertChannelSubscription {
    activated: boolean;
    channelId: number;
}

export interface TcpCheckAlertSettings {
    /**
     * Determines the type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`. (Default `RUN_BASED`).
     */
    escalationType?: string;
    /**
     * Configuration for parallel run failure threshold.
     */
    parallelRunFailureThresholds: outputs.TcpCheckAlertSettingsParallelRunFailureThreshold[];
    /**
     * Defines how often to send reminder notifications after initial alert.
     */
    reminders: outputs.TcpCheckAlertSettingsReminder[];
    /**
     * Configuration for run-based escalation.
     */
    runBasedEscalations: outputs.TcpCheckAlertSettingsRunBasedEscalation[];
    /**
     * Configuration for time-based escalation.
     */
    timeBasedEscalations: outputs.TcpCheckAlertSettingsTimeBasedEscalation[];
}

export interface TcpCheckAlertSettingsParallelRunFailureThreshold {
    /**
     * Whether parallel run failure threshold is enabled. Only applies if the monitor is scheduled for multiple locations in parallel. (Default `false`).
     */
    enabled?: boolean;
    /**
     * Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
     */
    percentage?: number;
}

export interface TcpCheckAlertSettingsReminder {
    /**
     * Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
     */
    amount?: number;
    /**
     * Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    interval?: number;
}

export interface TcpCheckAlertSettingsRunBasedEscalation {
    /**
     * Send an alert notification after the given number of consecutive monitor runs have failed. Possible values are between `1` and `5`. (Default `1`).
     */
    failedRunThreshold?: number;
}

export interface TcpCheckAlertSettingsTimeBasedEscalation {
    /**
     * Send an alert notification after the monitor has been failing for the given amount of time (in minutes). Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    minutesFailingThreshold?: number;
}

export interface TcpCheckRequest {
    /**
     * A request can have multiple assertions.
     */
    assertions?: outputs.TcpCheckRequestAssertion[];
    /**
     * The data to send to the target host.
     */
    data?: string;
    /**
     * The hostname or IP to connect to. Do not include a scheme or a port in this value.
     */
    hostname: string;
    /**
     * The IP family to use when executing the TCP check. The value can be either `IPv4` or `IPv6`.
     */
    ipFamily?: string;
    /**
     * The port number to connect to.
     */
    port: number;
}

export interface TcpCheckRequestAssertion {
    /**
     * The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
     */
    comparison: string;
    property?: string;
    /**
     * The source of the asserted value. Possible values are `RESPONSE_DATA` and `RESPONSE_TIME`.
     */
    source: string;
    target?: string;
}

export interface TcpCheckRetryStrategy {
    /**
     * The number of seconds to wait before the first retry attempt. (Default `60`).
     */
    baseBackoffSeconds?: number;
    /**
     * The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
     */
    maxDurationSeconds?: number;
    /**
     * The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
     */
    maxRetries?: number;
    /**
     * Apply the retry strategy only if the defined conditions match.
     */
    onlyOn?: outputs.TcpCheckRetryStrategyOnlyOn;
    /**
     * Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
     */
    sameRegion?: boolean;
    /**
     * Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
     */
    type: string;
}

export interface TcpCheckRetryStrategyOnlyOn {
    /**
     * When `true`, retry only if the cause of the failure is a network error. (Default `false`).
     */
    networkError?: boolean;
}

export interface TcpCheckTriggerIncident {
    /**
     * A detailed description of the incident.
     */
    description: string;
    /**
     * The name of the incident.
     */
    name: string;
    /**
     * Whether to notify subscribers when the incident is triggered.
     */
    notifySubscribers: boolean;
    /**
     * The status page service that this incident will be associated with.
     */
    serviceId: string;
    /**
     * The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
     */
    severity: string;
}

export interface TcpMonitorAlertChannelSubscription {
    activated: boolean;
    channelId: number;
}

export interface TcpMonitorAlertSettings {
    /**
     * Determines the type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`. (Default `RUN_BASED`).
     */
    escalationType?: string;
    /**
     * Configuration for parallel run failure threshold.
     */
    parallelRunFailureThresholds: outputs.TcpMonitorAlertSettingsParallelRunFailureThreshold[];
    /**
     * Defines how often to send reminder notifications after initial alert.
     */
    reminders: outputs.TcpMonitorAlertSettingsReminder[];
    /**
     * Configuration for run-based escalation.
     */
    runBasedEscalations: outputs.TcpMonitorAlertSettingsRunBasedEscalation[];
    /**
     * Configuration for time-based escalation.
     */
    timeBasedEscalations: outputs.TcpMonitorAlertSettingsTimeBasedEscalation[];
}

export interface TcpMonitorAlertSettingsParallelRunFailureThreshold {
    /**
     * Whether parallel run failure threshold is enabled. Only applies if the monitor is scheduled for multiple locations in parallel. (Default `false`).
     */
    enabled?: boolean;
    /**
     * Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
     */
    percentage?: number;
}

export interface TcpMonitorAlertSettingsReminder {
    /**
     * Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
     */
    amount?: number;
    /**
     * Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    interval?: number;
}

export interface TcpMonitorAlertSettingsRunBasedEscalation {
    /**
     * Send an alert notification after the given number of consecutive monitor runs have failed. Possible values are between `1` and `5`. (Default `1`).
     */
    failedRunThreshold?: number;
}

export interface TcpMonitorAlertSettingsTimeBasedEscalation {
    /**
     * Send an alert notification after the monitor has been failing for the given amount of time (in minutes). Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    minutesFailingThreshold?: number;
}

export interface TcpMonitorRequest {
    /**
     * A request can have multiple assertions.
     */
    assertions?: outputs.TcpMonitorRequestAssertion[];
    /**
     * The data to send to the target host.
     */
    data?: string;
    /**
     * The hostname or IP to connect to. Do not include a scheme or a port in this value.
     */
    hostname: string;
    /**
     * The IP family to use when executing the TCP check. The value can be either `IPv4` or `IPv6`.
     */
    ipFamily?: string;
    /**
     * The port number to connect to.
     */
    port: number;
}

export interface TcpMonitorRequestAssertion {
    /**
     * The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
     */
    comparison: string;
    property?: string;
    /**
     * The source of the asserted value. Possible values are `RESPONSE_DATA` and `RESPONSE_TIME`.
     */
    source: string;
    target?: string;
}

export interface TcpMonitorRetryStrategy {
    /**
     * The number of seconds to wait before the first retry attempt. (Default `60`).
     */
    baseBackoffSeconds?: number;
    /**
     * The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
     */
    maxDurationSeconds?: number;
    /**
     * The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
     */
    maxRetries?: number;
    /**
     * Apply the retry strategy only if the defined conditions match.
     */
    onlyOn?: outputs.TcpMonitorRetryStrategyOnlyOn;
    /**
     * Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
     */
    sameRegion?: boolean;
    /**
     * Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
     */
    type: string;
}

export interface TcpMonitorRetryStrategyOnlyOn {
    /**
     * When `true`, retry only if the cause of the failure is a network error. (Default `false`).
     */
    networkError?: boolean;
}

export interface TcpMonitorTriggerIncident {
    /**
     * A detailed description of the incident.
     */
    description: string;
    /**
     * The name of the incident.
     */
    name: string;
    /**
     * Whether to notify subscribers when the incident is triggered.
     */
    notifySubscribers: boolean;
    /**
     * The status page service that this incident will be associated with.
     */
    serviceId: string;
    /**
     * The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
     */
    severity: string;
}

export interface UrlMonitorAlertChannelSubscription {
    /**
     * Whether an alert should be sent to this channel.
     */
    activated: boolean;
    /**
     * The ID of the alert channel.
     */
    channelId: number;
}

export interface UrlMonitorAlertSettings {
    /**
     * Determines the type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`. (Default `RUN_BASED`).
     */
    escalationType?: string;
    /**
     * Configuration for parallel run failure threshold.
     */
    parallelRunFailureThresholds: outputs.UrlMonitorAlertSettingsParallelRunFailureThreshold[];
    /**
     * Defines how often to send reminder notifications after initial alert.
     */
    reminders: outputs.UrlMonitorAlertSettingsReminder[];
    /**
     * Configuration for run-based escalation.
     */
    runBasedEscalations: outputs.UrlMonitorAlertSettingsRunBasedEscalation[];
    /**
     * Configuration for time-based escalation.
     */
    timeBasedEscalations: outputs.UrlMonitorAlertSettingsTimeBasedEscalation[];
}

export interface UrlMonitorAlertSettingsParallelRunFailureThreshold {
    /**
     * Whether parallel run failure threshold is enabled. Only applies if the monitor is scheduled for multiple locations in parallel. (Default `false`).
     */
    enabled?: boolean;
    /**
     * Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
     */
    percentage?: number;
}

export interface UrlMonitorAlertSettingsReminder {
    /**
     * Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
     */
    amount?: number;
    /**
     * Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    interval?: number;
}

export interface UrlMonitorAlertSettingsRunBasedEscalation {
    /**
     * Send an alert notification after the given number of consecutive monitor runs have failed. Possible values are between `1` and `5`. (Default `1`).
     */
    failedRunThreshold?: number;
}

export interface UrlMonitorAlertSettingsTimeBasedEscalation {
    /**
     * Send an alert notification after the monitor has been failing for the given amount of time (in minutes). Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
     */
    minutesFailingThreshold?: number;
}

export interface UrlMonitorRequest {
    /**
     * Assertions to validate the HTTP response. URL monitors only support status code assertions.
     */
    assertions?: outputs.UrlMonitorRequestAssertion[];
    /**
     * Whether to follow HTTP redirects automatically. (Default `true`).
     */
    followRedirects?: boolean;
    /**
     * IP family version to use for the connection. The value can be either `IPv4` or `IPv6`. (Default `IPv4`).
     */
    ipFamily?: string;
    /**
     * Whether to skip SSL certificate verification. (Default `false`).
     */
    skipSsl?: boolean;
    /**
     * The URL to monitor. Must be a valid HTTP or HTTPS URL.
     */
    url: string;
}

export interface UrlMonitorRequestAssertion {
    /**
     * The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `GREATER_THAN` and `LESS_THAN`.
     */
    comparison: string;
    property?: string;
    /**
     * The source of the asserted value. The only allowed value is `STATUS_CODE`.
     */
    source: string;
    /**
     * The target value. Typically `200` when the source is `STATUS_CODE`.
     */
    target: string;
}

export interface UrlMonitorRetryStrategy {
    /**
     * The number of seconds to wait before the first retry attempt. (Default `60`).
     */
    baseBackoffSeconds?: number;
    /**
     * The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
     */
    maxDurationSeconds?: number;
    /**
     * The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
     */
    maxRetries?: number;
    /**
     * Apply the retry strategy only if the defined conditions match.
     */
    onlyOn?: outputs.UrlMonitorRetryStrategyOnlyOn;
    /**
     * Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
     */
    sameRegion?: boolean;
    /**
     * Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
     */
    type: string;
}

export interface UrlMonitorRetryStrategyOnlyOn {
    /**
     * When `true`, retry only if the cause of the failure is a network error. (Default `false`).
     */
    networkError?: boolean;
}

export interface UrlMonitorTriggerIncident {
    /**
     * A detailed description of the incident.
     */
    description: string;
    /**
     * The name of the incident.
     */
    name: string;
    /**
     * Whether to notify subscribers when the incident is triggered.
     */
    notifySubscribers: boolean;
    /**
     * The status page service that this incident will be associated with.
     */
    serviceId: string;
    /**
     * The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
     */
    severity: string;
}

