// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * TCP checks allow you to monitor remote endpoints at a lower level.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as checkly from "@checkly/pulumi";
 *
 * // Basic TCP monitor
 * const example_tcp_monitor = new checkly.TcpMonitor("example-tcp-monitor", {
 *     name: "Example TCP monitor",
 *     activated: true,
 *     shouldFail: false,
 *     frequency: 1,
 *     useGlobalAlertSettings: true,
 *     locations: ["us-west-1"],
 *     request: {
 *         hostname: "api.checklyhq.com",
 *         port: 80,
 *     },
 * });
 * // A more complex example using assertions and setting alerts
 * const example_tcp_monitor_2 = new checkly.TcpMonitor("example-tcp-monitor-2", {
 *     name: "Example TCP monitor 2",
 *     activated: true,
 *     shouldFail: true,
 *     frequency: 1,
 *     degradedResponseTime: 5000,
 *     maxResponseTime: 10000,
 *     locations: [
 *         "us-west-1",
 *         "ap-northeast-1",
 *         "ap-south-1",
 *     ],
 *     alertSettings: {
 *         escalationType: "RUN_BASED",
 *         runBasedEscalations: [{
 *             failedRunThreshold: 1,
 *         }],
 *         reminders: [{
 *             amount: 1,
 *         }],
 *     },
 *     retryStrategy: {
 *         type: "FIXED",
 *         baseBackoffSeconds: 60,
 *         maxDurationSeconds: 600,
 *         maxRetries: 3,
 *         sameRegion: false,
 *     },
 *     request: {
 *         hostname: "api.checklyhq.com",
 *         port: 80,
 *         data: "hello",
 *         assertions: [
 *             {
 *                 source: "RESPONSE_DATA",
 *                 property: "",
 *                 comparison: "CONTAINS",
 *                 target: "welcome",
 *             },
 *             {
 *                 source: "RESPONSE_TIME",
 *                 property: "",
 *                 comparison: "LESS_THAN",
 *                 target: "2000",
 *             },
 *         ],
 *     },
 * });
 * ```
 */
export class TcpMonitor extends pulumi.CustomResource {
    /**
     * Get an existing TcpMonitor resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: TcpMonitorState, opts?: pulumi.CustomResourceOptions): TcpMonitor {
        return new TcpMonitor(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'checkly:index/tcpMonitor:TcpMonitor';

    /**
     * Returns true if the given object is an instance of TcpMonitor.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is TcpMonitor {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === TcpMonitor.__pulumiType;
    }

    /**
     * Determines if the check is running or not. Possible values `true`, and `false`.
     */
    declare public readonly activated: pulumi.Output<boolean>;
    /**
     * An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
     */
    declare public readonly alertChannelSubscriptions: pulumi.Output<outputs.TcpMonitorAlertChannelSubscription[] | undefined>;
    /**
     * Determines the alert escalation policy for the monitor.
     */
    declare public readonly alertSettings: pulumi.Output<outputs.TcpMonitorAlertSettings>;
    /**
     * The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
     */
    declare public readonly degradedResponseTime: pulumi.Output<number | undefined>;
    /**
     * The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
     */
    declare public readonly frequency: pulumi.Output<number>;
    /**
     * To create a high frequency check, the property `frequency` must be `0` and `frequencyOffset` can be `10`, `20` or `30`.
     */
    declare public readonly frequencyOffset: pulumi.Output<number | undefined>;
    /**
     * The id of the check group this check is part of.
     */
    declare public readonly groupId: pulumi.Output<number | undefined>;
    /**
     * The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
     */
    declare public readonly groupOrder: pulumi.Output<number | undefined>;
    /**
     * An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
     */
    declare public readonly locations: pulumi.Output<string[] | undefined>;
    /**
     * The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
     */
    declare public readonly maxResponseTime: pulumi.Output<number | undefined>;
    /**
     * Determines if any notifications will be sent out when a check fails/degrades/recovers.
     */
    declare public readonly muted: pulumi.Output<boolean | undefined>;
    /**
     * The name of the check.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * An array of one or more private locations slugs.
     */
    declare public readonly privateLocations: pulumi.Output<string[] | undefined>;
    /**
     * The parameters for the TCP connection.
     */
    declare public readonly request: pulumi.Output<outputs.TcpMonitorRequest>;
    /**
     * A strategy for retrying failed check/monitor runs.
     */
    declare public readonly retryStrategy: pulumi.Output<outputs.TcpMonitorRetryStrategy>;
    /**
     * Determines if the check should run in all selected locations in parallel or round-robin.
     */
    declare public readonly runParallel: pulumi.Output<boolean | undefined>;
    /**
     * The ID of the runtime to use for this check.
     */
    declare public readonly runtimeId: pulumi.Output<string | undefined>;
    /**
     * Allows to invert the behaviour of when a check is considered to fail.
     */
    declare public readonly shouldFail: pulumi.Output<boolean | undefined>;
    /**
     * A list of tags for organizing and filtering checks.
     */
    declare public readonly tags: pulumi.Output<string[] | undefined>;
    /**
     * Create and resolve an incident based on the alert configuration. Useful for status page automation.
     */
    declare public readonly triggerIncident: pulumi.Output<outputs.TcpMonitorTriggerIncident | undefined>;
    /**
     * When true, the account level alert settings will be used, not the alert setting defined on this check.
     */
    declare public readonly useGlobalAlertSettings: pulumi.Output<boolean | undefined>;

    /**
     * Create a TcpMonitor resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: TcpMonitorArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: TcpMonitorArgs | TcpMonitorState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as TcpMonitorState | undefined;
            resourceInputs["activated"] = state?.activated;
            resourceInputs["alertChannelSubscriptions"] = state?.alertChannelSubscriptions;
            resourceInputs["alertSettings"] = state?.alertSettings;
            resourceInputs["degradedResponseTime"] = state?.degradedResponseTime;
            resourceInputs["frequency"] = state?.frequency;
            resourceInputs["frequencyOffset"] = state?.frequencyOffset;
            resourceInputs["groupId"] = state?.groupId;
            resourceInputs["groupOrder"] = state?.groupOrder;
            resourceInputs["locations"] = state?.locations;
            resourceInputs["maxResponseTime"] = state?.maxResponseTime;
            resourceInputs["muted"] = state?.muted;
            resourceInputs["name"] = state?.name;
            resourceInputs["privateLocations"] = state?.privateLocations;
            resourceInputs["request"] = state?.request;
            resourceInputs["retryStrategy"] = state?.retryStrategy;
            resourceInputs["runParallel"] = state?.runParallel;
            resourceInputs["runtimeId"] = state?.runtimeId;
            resourceInputs["shouldFail"] = state?.shouldFail;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["triggerIncident"] = state?.triggerIncident;
            resourceInputs["useGlobalAlertSettings"] = state?.useGlobalAlertSettings;
        } else {
            const args = argsOrState as TcpMonitorArgs | undefined;
            if (args?.activated === undefined && !opts.urn) {
                throw new Error("Missing required property 'activated'");
            }
            if (args?.frequency === undefined && !opts.urn) {
                throw new Error("Missing required property 'frequency'");
            }
            if (args?.request === undefined && !opts.urn) {
                throw new Error("Missing required property 'request'");
            }
            resourceInputs["activated"] = args?.activated;
            resourceInputs["alertChannelSubscriptions"] = args?.alertChannelSubscriptions;
            resourceInputs["alertSettings"] = args?.alertSettings;
            resourceInputs["degradedResponseTime"] = args?.degradedResponseTime;
            resourceInputs["frequency"] = args?.frequency;
            resourceInputs["frequencyOffset"] = args?.frequencyOffset;
            resourceInputs["groupId"] = args?.groupId;
            resourceInputs["groupOrder"] = args?.groupOrder;
            resourceInputs["locations"] = args?.locations;
            resourceInputs["maxResponseTime"] = args?.maxResponseTime;
            resourceInputs["muted"] = args?.muted;
            resourceInputs["name"] = args?.name;
            resourceInputs["privateLocations"] = args?.privateLocations;
            resourceInputs["request"] = args?.request;
            resourceInputs["retryStrategy"] = args?.retryStrategy;
            resourceInputs["runParallel"] = args?.runParallel;
            resourceInputs["runtimeId"] = args?.runtimeId;
            resourceInputs["shouldFail"] = args?.shouldFail;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["triggerIncident"] = args?.triggerIncident;
            resourceInputs["useGlobalAlertSettings"] = args?.useGlobalAlertSettings;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(TcpMonitor.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering TcpMonitor resources.
 */
export interface TcpMonitorState {
    /**
     * Determines if the check is running or not. Possible values `true`, and `false`.
     */
    activated?: pulumi.Input<boolean>;
    /**
     * An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
     */
    alertChannelSubscriptions?: pulumi.Input<pulumi.Input<inputs.TcpMonitorAlertChannelSubscription>[]>;
    /**
     * Determines the alert escalation policy for the monitor.
     */
    alertSettings?: pulumi.Input<inputs.TcpMonitorAlertSettings>;
    /**
     * The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
     */
    degradedResponseTime?: pulumi.Input<number>;
    /**
     * The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
     */
    frequency?: pulumi.Input<number>;
    /**
     * To create a high frequency check, the property `frequency` must be `0` and `frequencyOffset` can be `10`, `20` or `30`.
     */
    frequencyOffset?: pulumi.Input<number>;
    /**
     * The id of the check group this check is part of.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
     */
    groupOrder?: pulumi.Input<number>;
    /**
     * An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
     */
    locations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
     */
    maxResponseTime?: pulumi.Input<number>;
    /**
     * Determines if any notifications will be sent out when a check fails/degrades/recovers.
     */
    muted?: pulumi.Input<boolean>;
    /**
     * The name of the check.
     */
    name?: pulumi.Input<string>;
    /**
     * An array of one or more private locations slugs.
     */
    privateLocations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The parameters for the TCP connection.
     */
    request?: pulumi.Input<inputs.TcpMonitorRequest>;
    /**
     * A strategy for retrying failed check/monitor runs.
     */
    retryStrategy?: pulumi.Input<inputs.TcpMonitorRetryStrategy>;
    /**
     * Determines if the check should run in all selected locations in parallel or round-robin.
     */
    runParallel?: pulumi.Input<boolean>;
    /**
     * The ID of the runtime to use for this check.
     */
    runtimeId?: pulumi.Input<string>;
    /**
     * Allows to invert the behaviour of when a check is considered to fail.
     */
    shouldFail?: pulumi.Input<boolean>;
    /**
     * A list of tags for organizing and filtering checks.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Create and resolve an incident based on the alert configuration. Useful for status page automation.
     */
    triggerIncident?: pulumi.Input<inputs.TcpMonitorTriggerIncident>;
    /**
     * When true, the account level alert settings will be used, not the alert setting defined on this check.
     */
    useGlobalAlertSettings?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a TcpMonitor resource.
 */
export interface TcpMonitorArgs {
    /**
     * Determines if the check is running or not. Possible values `true`, and `false`.
     */
    activated: pulumi.Input<boolean>;
    /**
     * An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
     */
    alertChannelSubscriptions?: pulumi.Input<pulumi.Input<inputs.TcpMonitorAlertChannelSubscription>[]>;
    /**
     * Determines the alert escalation policy for the monitor.
     */
    alertSettings?: pulumi.Input<inputs.TcpMonitorAlertSettings>;
    /**
     * The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
     */
    degradedResponseTime?: pulumi.Input<number>;
    /**
     * The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
     */
    frequency: pulumi.Input<number>;
    /**
     * To create a high frequency check, the property `frequency` must be `0` and `frequencyOffset` can be `10`, `20` or `30`.
     */
    frequencyOffset?: pulumi.Input<number>;
    /**
     * The id of the check group this check is part of.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
     */
    groupOrder?: pulumi.Input<number>;
    /**
     * An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
     */
    locations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
     */
    maxResponseTime?: pulumi.Input<number>;
    /**
     * Determines if any notifications will be sent out when a check fails/degrades/recovers.
     */
    muted?: pulumi.Input<boolean>;
    /**
     * The name of the check.
     */
    name?: pulumi.Input<string>;
    /**
     * An array of one or more private locations slugs.
     */
    privateLocations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The parameters for the TCP connection.
     */
    request: pulumi.Input<inputs.TcpMonitorRequest>;
    /**
     * A strategy for retrying failed check/monitor runs.
     */
    retryStrategy?: pulumi.Input<inputs.TcpMonitorRetryStrategy>;
    /**
     * Determines if the check should run in all selected locations in parallel or round-robin.
     */
    runParallel?: pulumi.Input<boolean>;
    /**
     * The ID of the runtime to use for this check.
     */
    runtimeId?: pulumi.Input<string>;
    /**
     * Allows to invert the behaviour of when a check is considered to fail.
     */
    shouldFail?: pulumi.Input<boolean>;
    /**
     * A list of tags for organizing and filtering checks.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Create and resolve an incident based on the alert configuration. Useful for status page automation.
     */
    triggerIncident?: pulumi.Input<inputs.TcpMonitorTriggerIncident>;
    /**
     * When true, the account level alert settings will be used, not the alert setting defined on this check.
     */
    useGlobalAlertSettings?: pulumi.Input<boolean>;
}
