// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * TCP checks allow you to monitor remote endpoints at a lower level.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as checkly from "@checkly/pulumi";
 *
 * // Basic TCP Check
 * const example_tcp_check = new checkly.TcpCheck("example-tcp-check", {
 *     name: "Example TCP check",
 *     activated: true,
 *     shouldFail: false,
 *     frequency: 1,
 *     useGlobalAlertSettings: true,
 *     locations: ["us-west-1"],
 *     request: {
 *         hostname: "api.checklyhq.com",
 *         port: 80,
 *     },
 * });
 * // A more complex example using assertions and setting alerts
 * const example_tcp_check_2 = new checkly.TcpCheck("example-tcp-check-2", {
 *     name: "Example TCP check 2",
 *     activated: true,
 *     shouldFail: true,
 *     frequency: 1,
 *     degradedResponseTime: 5000,
 *     maxResponseTime: 10000,
 *     locations: [
 *         "us-west-1",
 *         "ap-northeast-1",
 *         "ap-south-1",
 *     ],
 *     alertSettings: {
 *         escalationType: "RUN_BASED",
 *         runBasedEscalations: [{
 *             failedRunThreshold: 1,
 *         }],
 *         reminders: [{
 *             amount: 1,
 *         }],
 *     },
 *     retryStrategy: {
 *         type: "FIXED",
 *         baseBackoffSeconds: 60,
 *         maxDurationSeconds: 600,
 *         maxRetries: 3,
 *         sameRegion: false,
 *     },
 *     request: {
 *         hostname: "api.checklyhq.com",
 *         port: 80,
 *         data: "hello",
 *         assertions: [
 *             {
 *                 source: "RESPONSE_DATA",
 *                 property: "",
 *                 comparison: "CONTAINS",
 *                 target: "welcome",
 *             },
 *             {
 *                 source: "RESPONSE_TIME",
 *                 property: "",
 *                 comparison: "LESS_THAN",
 *                 target: "2000",
 *             },
 *         ],
 *     },
 * });
 * ```
 */
export class TcpCheck extends pulumi.CustomResource {
    /**
     * Get an existing TcpCheck resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: TcpCheckState, opts?: pulumi.CustomResourceOptions): TcpCheck {
        return new TcpCheck(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'checkly:index/tcpCheck:TcpCheck';

    /**
     * Returns true if the given object is an instance of TcpCheck.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is TcpCheck {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === TcpCheck.__pulumiType;
    }

    /**
     * Determines if the check is running or not. Possible values `true`, and `false`.
     */
    public readonly activated!: pulumi.Output<boolean>;
    /**
     * An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
     */
    public readonly alertChannelSubscriptions!: pulumi.Output<outputs.TcpCheckAlertChannelSubscription[] | undefined>;
    public readonly alertSettings!: pulumi.Output<outputs.TcpCheckAlertSettings>;
    /**
     * The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
     */
    public readonly degradedResponseTime!: pulumi.Output<number | undefined>;
    /**
     * The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
     */
    public readonly frequency!: pulumi.Output<number>;
    /**
     * To create a high frequency check, the property `frequency` must be `0` and `frequencyOffset` can be `10`, `20` or `30`.
     */
    public readonly frequencyOffset!: pulumi.Output<number | undefined>;
    /**
     * The id of the check group this check is part of.
     */
    public readonly groupId!: pulumi.Output<number | undefined>;
    /**
     * The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
     */
    public readonly groupOrder!: pulumi.Output<number | undefined>;
    /**
     * An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
     */
    public readonly locations!: pulumi.Output<string[] | undefined>;
    /**
     * The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
     */
    public readonly maxResponseTime!: pulumi.Output<number | undefined>;
    /**
     * Determines if any notifications will be sent out when a check fails/degrades/recovers.
     */
    public readonly muted!: pulumi.Output<boolean | undefined>;
    /**
     * The name of the check.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * An array of one or more private locations slugs.
     */
    public readonly privateLocations!: pulumi.Output<string[] | undefined>;
    /**
     * The parameters for the TCP connection.
     */
    public readonly request!: pulumi.Output<outputs.TcpCheckRequest>;
    /**
     * A strategy for retrying failed check runs.
     */
    public readonly retryStrategy!: pulumi.Output<outputs.TcpCheckRetryStrategy>;
    /**
     * Determines if the check should run in all selected locations in parallel or round-robin.
     */
    public readonly runParallel!: pulumi.Output<boolean | undefined>;
    /**
     * The ID of the runtime to use for this check.
     */
    public readonly runtimeId!: pulumi.Output<string | undefined>;
    /**
     * Allows to invert the behaviour of when a check is considered to fail.
     */
    public readonly shouldFail!: pulumi.Output<boolean | undefined>;
    /**
     * A list of tags for organizing and filtering checks.
     */
    public readonly tags!: pulumi.Output<string[] | undefined>;
    /**
     * When true, the account level alert settings will be used, not the alert setting defined on this check.
     */
    public readonly useGlobalAlertSettings!: pulumi.Output<boolean | undefined>;

    /**
     * Create a TcpCheck resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: TcpCheckArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: TcpCheckArgs | TcpCheckState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as TcpCheckState | undefined;
            resourceInputs["activated"] = state ? state.activated : undefined;
            resourceInputs["alertChannelSubscriptions"] = state ? state.alertChannelSubscriptions : undefined;
            resourceInputs["alertSettings"] = state ? state.alertSettings : undefined;
            resourceInputs["degradedResponseTime"] = state ? state.degradedResponseTime : undefined;
            resourceInputs["frequency"] = state ? state.frequency : undefined;
            resourceInputs["frequencyOffset"] = state ? state.frequencyOffset : undefined;
            resourceInputs["groupId"] = state ? state.groupId : undefined;
            resourceInputs["groupOrder"] = state ? state.groupOrder : undefined;
            resourceInputs["locations"] = state ? state.locations : undefined;
            resourceInputs["maxResponseTime"] = state ? state.maxResponseTime : undefined;
            resourceInputs["muted"] = state ? state.muted : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["privateLocations"] = state ? state.privateLocations : undefined;
            resourceInputs["request"] = state ? state.request : undefined;
            resourceInputs["retryStrategy"] = state ? state.retryStrategy : undefined;
            resourceInputs["runParallel"] = state ? state.runParallel : undefined;
            resourceInputs["runtimeId"] = state ? state.runtimeId : undefined;
            resourceInputs["shouldFail"] = state ? state.shouldFail : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["useGlobalAlertSettings"] = state ? state.useGlobalAlertSettings : undefined;
        } else {
            const args = argsOrState as TcpCheckArgs | undefined;
            if ((!args || args.activated === undefined) && !opts.urn) {
                throw new Error("Missing required property 'activated'");
            }
            if ((!args || args.frequency === undefined) && !opts.urn) {
                throw new Error("Missing required property 'frequency'");
            }
            if ((!args || args.request === undefined) && !opts.urn) {
                throw new Error("Missing required property 'request'");
            }
            resourceInputs["activated"] = args ? args.activated : undefined;
            resourceInputs["alertChannelSubscriptions"] = args ? args.alertChannelSubscriptions : undefined;
            resourceInputs["alertSettings"] = args ? args.alertSettings : undefined;
            resourceInputs["degradedResponseTime"] = args ? args.degradedResponseTime : undefined;
            resourceInputs["frequency"] = args ? args.frequency : undefined;
            resourceInputs["frequencyOffset"] = args ? args.frequencyOffset : undefined;
            resourceInputs["groupId"] = args ? args.groupId : undefined;
            resourceInputs["groupOrder"] = args ? args.groupOrder : undefined;
            resourceInputs["locations"] = args ? args.locations : undefined;
            resourceInputs["maxResponseTime"] = args ? args.maxResponseTime : undefined;
            resourceInputs["muted"] = args ? args.muted : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["privateLocations"] = args ? args.privateLocations : undefined;
            resourceInputs["request"] = args ? args.request : undefined;
            resourceInputs["retryStrategy"] = args ? args.retryStrategy : undefined;
            resourceInputs["runParallel"] = args ? args.runParallel : undefined;
            resourceInputs["runtimeId"] = args ? args.runtimeId : undefined;
            resourceInputs["shouldFail"] = args ? args.shouldFail : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["useGlobalAlertSettings"] = args ? args.useGlobalAlertSettings : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(TcpCheck.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering TcpCheck resources.
 */
export interface TcpCheckState {
    /**
     * Determines if the check is running or not. Possible values `true`, and `false`.
     */
    activated?: pulumi.Input<boolean>;
    /**
     * An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
     */
    alertChannelSubscriptions?: pulumi.Input<pulumi.Input<inputs.TcpCheckAlertChannelSubscription>[]>;
    alertSettings?: pulumi.Input<inputs.TcpCheckAlertSettings>;
    /**
     * The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
     */
    degradedResponseTime?: pulumi.Input<number>;
    /**
     * The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
     */
    frequency?: pulumi.Input<number>;
    /**
     * To create a high frequency check, the property `frequency` must be `0` and `frequencyOffset` can be `10`, `20` or `30`.
     */
    frequencyOffset?: pulumi.Input<number>;
    /**
     * The id of the check group this check is part of.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
     */
    groupOrder?: pulumi.Input<number>;
    /**
     * An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
     */
    locations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
     */
    maxResponseTime?: pulumi.Input<number>;
    /**
     * Determines if any notifications will be sent out when a check fails/degrades/recovers.
     */
    muted?: pulumi.Input<boolean>;
    /**
     * The name of the check.
     */
    name?: pulumi.Input<string>;
    /**
     * An array of one or more private locations slugs.
     */
    privateLocations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The parameters for the TCP connection.
     */
    request?: pulumi.Input<inputs.TcpCheckRequest>;
    /**
     * A strategy for retrying failed check runs.
     */
    retryStrategy?: pulumi.Input<inputs.TcpCheckRetryStrategy>;
    /**
     * Determines if the check should run in all selected locations in parallel or round-robin.
     */
    runParallel?: pulumi.Input<boolean>;
    /**
     * The ID of the runtime to use for this check.
     */
    runtimeId?: pulumi.Input<string>;
    /**
     * Allows to invert the behaviour of when a check is considered to fail.
     */
    shouldFail?: pulumi.Input<boolean>;
    /**
     * A list of tags for organizing and filtering checks.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When true, the account level alert settings will be used, not the alert setting defined on this check.
     */
    useGlobalAlertSettings?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a TcpCheck resource.
 */
export interface TcpCheckArgs {
    /**
     * Determines if the check is running or not. Possible values `true`, and `false`.
     */
    activated: pulumi.Input<boolean>;
    /**
     * An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
     */
    alertChannelSubscriptions?: pulumi.Input<pulumi.Input<inputs.TcpCheckAlertChannelSubscription>[]>;
    alertSettings?: pulumi.Input<inputs.TcpCheckAlertSettings>;
    /**
     * The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
     */
    degradedResponseTime?: pulumi.Input<number>;
    /**
     * The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
     */
    frequency: pulumi.Input<number>;
    /**
     * To create a high frequency check, the property `frequency` must be `0` and `frequencyOffset` can be `10`, `20` or `30`.
     */
    frequencyOffset?: pulumi.Input<number>;
    /**
     * The id of the check group this check is part of.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
     */
    groupOrder?: pulumi.Input<number>;
    /**
     * An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
     */
    locations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
     */
    maxResponseTime?: pulumi.Input<number>;
    /**
     * Determines if any notifications will be sent out when a check fails/degrades/recovers.
     */
    muted?: pulumi.Input<boolean>;
    /**
     * The name of the check.
     */
    name?: pulumi.Input<string>;
    /**
     * An array of one or more private locations slugs.
     */
    privateLocations?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The parameters for the TCP connection.
     */
    request: pulumi.Input<inputs.TcpCheckRequest>;
    /**
     * A strategy for retrying failed check runs.
     */
    retryStrategy?: pulumi.Input<inputs.TcpCheckRetryStrategy>;
    /**
     * Determines if the check should run in all selected locations in parallel or round-robin.
     */
    runParallel?: pulumi.Input<boolean>;
    /**
     * The ID of the runtime to use for this check.
     */
    runtimeId?: pulumi.Input<string>;
    /**
     * Allows to invert the behaviour of when a check is considered to fail.
     */
    shouldFail?: pulumi.Input<boolean>;
    /**
     * A list of tags for organizing and filtering checks.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When true, the account level alert settings will be used, not the alert setting defined on this check.
     */
    useGlobalAlertSettings?: pulumi.Input<boolean>;
}
