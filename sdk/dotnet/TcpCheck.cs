// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Checkly
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Checkly = Pulumi.Checkly;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Basic TCP Check
    ///     var example_tcp_check = new Checkly.TcpCheck("example-tcp-check", new()
    ///     {
    ///         Name = "Example TCP check",
    ///         Activated = true,
    ///         ShouldFail = false,
    ///         Frequency = 1,
    ///         UseGlobalAlertSettings = true,
    ///         Locations = new[]
    ///         {
    ///             "us-west-1",
    ///         },
    ///         Request = new Checkly.Inputs.TcpCheckRequestArgs
    ///         {
    ///             Hostname = "api.checklyhq.com",
    ///             Port = 80,
    ///         },
    ///     });
    /// 
    ///     // A more complex example using assertions and setting alerts
    ///     var example_tcp_check_2 = new Checkly.TcpCheck("example-tcp-check-2", new()
    ///     {
    ///         Name = "Example TCP check 2",
    ///         Activated = true,
    ///         ShouldFail = true,
    ///         Frequency = 1,
    ///         DegradedResponseTime = 5000,
    ///         MaxResponseTime = 10000,
    ///         Locations = new[]
    ///         {
    ///             "us-west-1",
    ///             "ap-northeast-1",
    ///             "ap-south-1",
    ///         },
    ///         AlertSettings = new Checkly.Inputs.TcpCheckAlertSettingsArgs
    ///         {
    ///             EscalationType = "RUN_BASED",
    ///             RunBasedEscalations = new[]
    ///             {
    ///                 new Checkly.Inputs.TcpCheckAlertSettingsRunBasedEscalationArgs
    ///                 {
    ///                     FailedRunThreshold = 1,
    ///                 },
    ///             },
    ///             Reminders = new[]
    ///             {
    ///                 new Checkly.Inputs.TcpCheckAlertSettingsReminderArgs
    ///                 {
    ///                     Amount = 1,
    ///                 },
    ///             },
    ///         },
    ///         RetryStrategy = new Checkly.Inputs.TcpCheckRetryStrategyArgs
    ///         {
    ///             Type = "FIXED",
    ///             BaseBackoffSeconds = 60,
    ///             MaxDurationSeconds = 600,
    ///             MaxRetries = 3,
    ///             SameRegion = false,
    ///         },
    ///         Request = new Checkly.Inputs.TcpCheckRequestArgs
    ///         {
    ///             Hostname = "api.checklyhq.com",
    ///             Port = 80,
    ///             Data = "hello",
    ///             Assertions = new[]
    ///             {
    ///                 new Checkly.Inputs.TcpCheckRequestAssertionArgs
    ///                 {
    ///                     Source = "RESPONSE_DATA",
    ///                     Property = "",
    ///                     Comparison = "CONTAINS",
    ///                     Target = "welcome",
    ///                 },
    ///                 new Checkly.Inputs.TcpCheckRequestAssertionArgs
    ///                 {
    ///                     Source = "RESPONSE_TIME",
    ///                     Property = "",
    ///                     Comparison = "LESS_THAN",
    ///                     Target = "2000",
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [ChecklyResourceType("checkly:index/tcpCheck:TcpCheck")]
    public partial class TcpCheck : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Determines if the check is running or not. Possible values `true`, and `false`.
        /// </summary>
        [Output("activated")]
        public Output<bool> Activated { get; private set; } = null!;

        /// <summary>
        /// An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        /// </summary>
        [Output("alertChannelSubscriptions")]
        public Output<ImmutableArray<Outputs.TcpCheckAlertChannelSubscription>> AlertChannelSubscriptions { get; private set; } = null!;

        /// <summary>
        /// Determines the alert escalation policy for the monitor.
        /// </summary>
        [Output("alertSettings")]
        public Output<Outputs.TcpCheckAlertSettings> AlertSettings { get; private set; } = null!;

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        /// </summary>
        [Output("degradedResponseTime")]
        public Output<int?> DegradedResponseTime { get; private set; } = null!;

        /// <summary>
        /// The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        /// </summary>
        [Output("frequency")]
        public Output<int> Frequency { get; private set; } = null!;

        /// <summary>
        /// To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        /// </summary>
        [Output("frequencyOffset")]
        public Output<int?> FrequencyOffset { get; private set; } = null!;

        /// <summary>
        /// The id of the check group this check is part of.
        /// </summary>
        [Output("groupId")]
        public Output<int?> GroupId { get; private set; } = null!;

        /// <summary>
        /// The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        /// </summary>
        [Output("groupOrder")]
        public Output<int?> GroupOrder { get; private set; } = null!;

        /// <summary>
        /// An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        /// </summary>
        [Output("locations")]
        public Output<ImmutableArray<string>> Locations { get; private set; } = null!;

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        /// </summary>
        [Output("maxResponseTime")]
        public Output<int?> MaxResponseTime { get; private set; } = null!;

        /// <summary>
        /// Determines if any notifications will be sent out when a check fails/degrades/recovers.
        /// </summary>
        [Output("muted")]
        public Output<bool?> Muted { get; private set; } = null!;

        /// <summary>
        /// The name of the check.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// An array of one or more private locations slugs.
        /// </summary>
        [Output("privateLocations")]
        public Output<ImmutableArray<string>> PrivateLocations { get; private set; } = null!;

        /// <summary>
        /// The parameters for the TCP connection.
        /// </summary>
        [Output("request")]
        public Output<Outputs.TcpCheckRequest> Request { get; private set; } = null!;

        /// <summary>
        /// A strategy for retrying failed check/monitor runs.
        /// </summary>
        [Output("retryStrategy")]
        public Output<Outputs.TcpCheckRetryStrategy> RetryStrategy { get; private set; } = null!;

        /// <summary>
        /// Determines if the check should run in all selected locations in parallel or round-robin.
        /// </summary>
        [Output("runParallel")]
        public Output<bool?> RunParallel { get; private set; } = null!;

        /// <summary>
        /// The ID of the runtime to use for this check.
        /// </summary>
        [Output("runtimeId")]
        public Output<string?> RuntimeId { get; private set; } = null!;

        /// <summary>
        /// Allows to invert the behaviour of when a check is considered to fail.
        /// </summary>
        [Output("shouldFail")]
        public Output<bool?> ShouldFail { get; private set; } = null!;

        /// <summary>
        /// A list of tags for organizing and filtering checks.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// Create and resolve an incident based on the alert configuration. Useful for status page automation.
        /// </summary>
        [Output("triggerIncident")]
        public Output<Outputs.TcpCheckTriggerIncident?> TriggerIncident { get; private set; } = null!;

        /// <summary>
        /// When true, the account level alert settings will be used, not the alert setting defined on this check.
        /// </summary>
        [Output("useGlobalAlertSettings")]
        public Output<bool?> UseGlobalAlertSettings { get; private set; } = null!;


        /// <summary>
        /// Create a TcpCheck resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public TcpCheck(string name, TcpCheckArgs args, CustomResourceOptions? options = null)
            : base("checkly:index/tcpCheck:TcpCheck", name, args ?? new TcpCheckArgs(), MakeResourceOptions(options, ""))
        {
        }

        private TcpCheck(string name, Input<string> id, TcpCheckState? state = null, CustomResourceOptions? options = null)
            : base("checkly:index/tcpCheck:TcpCheck", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/checkly",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing TcpCheck resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static TcpCheck Get(string name, Input<string> id, TcpCheckState? state = null, CustomResourceOptions? options = null)
        {
            return new TcpCheck(name, id, state, options);
        }
    }

    public sealed class TcpCheckArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines if the check is running or not. Possible values `true`, and `false`.
        /// </summary>
        [Input("activated", required: true)]
        public Input<bool> Activated { get; set; } = null!;

        [Input("alertChannelSubscriptions")]
        private InputList<Inputs.TcpCheckAlertChannelSubscriptionArgs>? _alertChannelSubscriptions;

        /// <summary>
        /// An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        /// </summary>
        public InputList<Inputs.TcpCheckAlertChannelSubscriptionArgs> AlertChannelSubscriptions
        {
            get => _alertChannelSubscriptions ?? (_alertChannelSubscriptions = new InputList<Inputs.TcpCheckAlertChannelSubscriptionArgs>());
            set => _alertChannelSubscriptions = value;
        }

        /// <summary>
        /// Determines the alert escalation policy for the monitor.
        /// </summary>
        [Input("alertSettings")]
        public Input<Inputs.TcpCheckAlertSettingsArgs>? AlertSettings { get; set; }

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        /// </summary>
        [Input("degradedResponseTime")]
        public Input<int>? DegradedResponseTime { get; set; }

        /// <summary>
        /// The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        /// </summary>
        [Input("frequency", required: true)]
        public Input<int> Frequency { get; set; } = null!;

        /// <summary>
        /// To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        /// </summary>
        [Input("frequencyOffset")]
        public Input<int>? FrequencyOffset { get; set; }

        /// <summary>
        /// The id of the check group this check is part of.
        /// </summary>
        [Input("groupId")]
        public Input<int>? GroupId { get; set; }

        /// <summary>
        /// The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        /// </summary>
        [Input("groupOrder")]
        public Input<int>? GroupOrder { get; set; }

        [Input("locations")]
        private InputList<string>? _locations;

        /// <summary>
        /// An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        /// </summary>
        public InputList<string> Locations
        {
            get => _locations ?? (_locations = new InputList<string>());
            set => _locations = value;
        }

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        /// </summary>
        [Input("maxResponseTime")]
        public Input<int>? MaxResponseTime { get; set; }

        /// <summary>
        /// Determines if any notifications will be sent out when a check fails/degrades/recovers.
        /// </summary>
        [Input("muted")]
        public Input<bool>? Muted { get; set; }

        /// <summary>
        /// The name of the check.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("privateLocations")]
        private InputList<string>? _privateLocations;

        /// <summary>
        /// An array of one or more private locations slugs.
        /// </summary>
        public InputList<string> PrivateLocations
        {
            get => _privateLocations ?? (_privateLocations = new InputList<string>());
            set => _privateLocations = value;
        }

        /// <summary>
        /// The parameters for the TCP connection.
        /// </summary>
        [Input("request", required: true)]
        public Input<Inputs.TcpCheckRequestArgs> Request { get; set; } = null!;

        /// <summary>
        /// A strategy for retrying failed check/monitor runs.
        /// </summary>
        [Input("retryStrategy")]
        public Input<Inputs.TcpCheckRetryStrategyArgs>? RetryStrategy { get; set; }

        /// <summary>
        /// Determines if the check should run in all selected locations in parallel or round-robin.
        /// </summary>
        [Input("runParallel")]
        public Input<bool>? RunParallel { get; set; }

        /// <summary>
        /// The ID of the runtime to use for this check.
        /// </summary>
        [Input("runtimeId")]
        public Input<string>? RuntimeId { get; set; }

        /// <summary>
        /// Allows to invert the behaviour of when a check is considered to fail.
        /// </summary>
        [Input("shouldFail")]
        public Input<bool>? ShouldFail { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tags for organizing and filtering checks.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Create and resolve an incident based on the alert configuration. Useful for status page automation.
        /// </summary>
        [Input("triggerIncident")]
        public Input<Inputs.TcpCheckTriggerIncidentArgs>? TriggerIncident { get; set; }

        /// <summary>
        /// When true, the account level alert settings will be used, not the alert setting defined on this check.
        /// </summary>
        [Input("useGlobalAlertSettings")]
        public Input<bool>? UseGlobalAlertSettings { get; set; }

        public TcpCheckArgs()
        {
        }
        public static new TcpCheckArgs Empty => new TcpCheckArgs();
    }

    public sealed class TcpCheckState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines if the check is running or not. Possible values `true`, and `false`.
        /// </summary>
        [Input("activated")]
        public Input<bool>? Activated { get; set; }

        [Input("alertChannelSubscriptions")]
        private InputList<Inputs.TcpCheckAlertChannelSubscriptionGetArgs>? _alertChannelSubscriptions;

        /// <summary>
        /// An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        /// </summary>
        public InputList<Inputs.TcpCheckAlertChannelSubscriptionGetArgs> AlertChannelSubscriptions
        {
            get => _alertChannelSubscriptions ?? (_alertChannelSubscriptions = new InputList<Inputs.TcpCheckAlertChannelSubscriptionGetArgs>());
            set => _alertChannelSubscriptions = value;
        }

        /// <summary>
        /// Determines the alert escalation policy for the monitor.
        /// </summary>
        [Input("alertSettings")]
        public Input<Inputs.TcpCheckAlertSettingsGetArgs>? AlertSettings { get; set; }

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        /// </summary>
        [Input("degradedResponseTime")]
        public Input<int>? DegradedResponseTime { get; set; }

        /// <summary>
        /// The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        /// </summary>
        [Input("frequency")]
        public Input<int>? Frequency { get; set; }

        /// <summary>
        /// To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        /// </summary>
        [Input("frequencyOffset")]
        public Input<int>? FrequencyOffset { get; set; }

        /// <summary>
        /// The id of the check group this check is part of.
        /// </summary>
        [Input("groupId")]
        public Input<int>? GroupId { get; set; }

        /// <summary>
        /// The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        /// </summary>
        [Input("groupOrder")]
        public Input<int>? GroupOrder { get; set; }

        [Input("locations")]
        private InputList<string>? _locations;

        /// <summary>
        /// An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        /// </summary>
        public InputList<string> Locations
        {
            get => _locations ?? (_locations = new InputList<string>());
            set => _locations = value;
        }

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        /// </summary>
        [Input("maxResponseTime")]
        public Input<int>? MaxResponseTime { get; set; }

        /// <summary>
        /// Determines if any notifications will be sent out when a check fails/degrades/recovers.
        /// </summary>
        [Input("muted")]
        public Input<bool>? Muted { get; set; }

        /// <summary>
        /// The name of the check.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("privateLocations")]
        private InputList<string>? _privateLocations;

        /// <summary>
        /// An array of one or more private locations slugs.
        /// </summary>
        public InputList<string> PrivateLocations
        {
            get => _privateLocations ?? (_privateLocations = new InputList<string>());
            set => _privateLocations = value;
        }

        /// <summary>
        /// The parameters for the TCP connection.
        /// </summary>
        [Input("request")]
        public Input<Inputs.TcpCheckRequestGetArgs>? Request { get; set; }

        /// <summary>
        /// A strategy for retrying failed check/monitor runs.
        /// </summary>
        [Input("retryStrategy")]
        public Input<Inputs.TcpCheckRetryStrategyGetArgs>? RetryStrategy { get; set; }

        /// <summary>
        /// Determines if the check should run in all selected locations in parallel or round-robin.
        /// </summary>
        [Input("runParallel")]
        public Input<bool>? RunParallel { get; set; }

        /// <summary>
        /// The ID of the runtime to use for this check.
        /// </summary>
        [Input("runtimeId")]
        public Input<string>? RuntimeId { get; set; }

        /// <summary>
        /// Allows to invert the behaviour of when a check is considered to fail.
        /// </summary>
        [Input("shouldFail")]
        public Input<bool>? ShouldFail { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tags for organizing and filtering checks.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Create and resolve an incident based on the alert configuration. Useful for status page automation.
        /// </summary>
        [Input("triggerIncident")]
        public Input<Inputs.TcpCheckTriggerIncidentGetArgs>? TriggerIncident { get; set; }

        /// <summary>
        /// When true, the account level alert settings will be used, not the alert setting defined on this check.
        /// </summary>
        [Input("useGlobalAlertSettings")]
        public Input<bool>? UseGlobalAlertSettings { get; set; }

        public TcpCheckState()
        {
        }
        public static new TcpCheckState Empty => new TcpCheckState();
    }
}
