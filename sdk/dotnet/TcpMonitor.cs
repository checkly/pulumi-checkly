// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Checkly
{
    /// <summary>
    /// TCP checks allow you to monitor remote endpoints at a lower level.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Checkly = Pulumi.Checkly;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Basic TCP monitor
    ///     var example_tcp_monitor = new Checkly.TcpMonitor("example-tcp-monitor", new()
    ///     {
    ///         Name = "Example TCP monitor",
    ///         Activated = true,
    ///         ShouldFail = false,
    ///         Frequency = 1,
    ///         UseGlobalAlertSettings = true,
    ///         Locations = new[]
    ///         {
    ///             "us-west-1",
    ///         },
    ///         Request = new Checkly.Inputs.TcpMonitorRequestArgs
    ///         {
    ///             Hostname = "api.checklyhq.com",
    ///             Port = 80,
    ///         },
    ///     });
    /// 
    ///     // A more complex example using assertions and setting alerts
    ///     var example_tcp_monitor_2 = new Checkly.TcpMonitor("example-tcp-monitor-2", new()
    ///     {
    ///         Name = "Example TCP monitor 2",
    ///         Activated = true,
    ///         ShouldFail = true,
    ///         Frequency = 1,
    ///         DegradedResponseTime = 5000,
    ///         MaxResponseTime = 10000,
    ///         Locations = new[]
    ///         {
    ///             "us-west-1",
    ///             "ap-northeast-1",
    ///             "ap-south-1",
    ///         },
    ///         AlertSettings = new Checkly.Inputs.TcpMonitorAlertSettingsArgs
    ///         {
    ///             EscalationType = "RUN_BASED",
    ///             RunBasedEscalations = new[]
    ///             {
    ///                 new Checkly.Inputs.TcpMonitorAlertSettingsRunBasedEscalationArgs
    ///                 {
    ///                     FailedRunThreshold = 1,
    ///                 },
    ///             },
    ///             Reminders = new[]
    ///             {
    ///                 new Checkly.Inputs.TcpMonitorAlertSettingsReminderArgs
    ///                 {
    ///                     Amount = 1,
    ///                 },
    ///             },
    ///         },
    ///         RetryStrategy = new Checkly.Inputs.TcpMonitorRetryStrategyArgs
    ///         {
    ///             Type = "FIXED",
    ///             BaseBackoffSeconds = 60,
    ///             MaxDurationSeconds = 600,
    ///             MaxRetries = 3,
    ///             SameRegion = false,
    ///         },
    ///         Request = new Checkly.Inputs.TcpMonitorRequestArgs
    ///         {
    ///             Hostname = "api.checklyhq.com",
    ///             Port = 80,
    ///             Data = "hello",
    ///             Assertions = new[]
    ///             {
    ///                 new Checkly.Inputs.TcpMonitorRequestAssertionArgs
    ///                 {
    ///                     Source = "RESPONSE_DATA",
    ///                     Property = "",
    ///                     Comparison = "CONTAINS",
    ///                     Target = "welcome",
    ///                 },
    ///                 new Checkly.Inputs.TcpMonitorRequestAssertionArgs
    ///                 {
    ///                     Source = "RESPONSE_TIME",
    ///                     Property = "",
    ///                     Comparison = "LESS_THAN",
    ///                     Target = "2000",
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [ChecklyResourceType("checkly:index/tcpMonitor:TcpMonitor")]
    public partial class TcpMonitor : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Determines if the check is running or not. Possible values `true`, and `false`.
        /// </summary>
        [Output("activated")]
        public Output<bool> Activated { get; private set; } = null!;

        /// <summary>
        /// An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        /// </summary>
        [Output("alertChannelSubscriptions")]
        public Output<ImmutableArray<Outputs.TcpMonitorAlertChannelSubscription>> AlertChannelSubscriptions { get; private set; } = null!;

        [Output("alertSettings")]
        public Output<Outputs.TcpMonitorAlertSettings> AlertSettings { get; private set; } = null!;

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        /// </summary>
        [Output("degradedResponseTime")]
        public Output<int?> DegradedResponseTime { get; private set; } = null!;

        /// <summary>
        /// The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        /// </summary>
        [Output("frequency")]
        public Output<int> Frequency { get; private set; } = null!;

        /// <summary>
        /// To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        /// </summary>
        [Output("frequencyOffset")]
        public Output<int?> FrequencyOffset { get; private set; } = null!;

        /// <summary>
        /// The id of the check group this check is part of.
        /// </summary>
        [Output("groupId")]
        public Output<int?> GroupId { get; private set; } = null!;

        /// <summary>
        /// The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        /// </summary>
        [Output("groupOrder")]
        public Output<int?> GroupOrder { get; private set; } = null!;

        /// <summary>
        /// An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        /// </summary>
        [Output("locations")]
        public Output<ImmutableArray<string>> Locations { get; private set; } = null!;

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        /// </summary>
        [Output("maxResponseTime")]
        public Output<int?> MaxResponseTime { get; private set; } = null!;

        /// <summary>
        /// Determines if any notifications will be sent out when a check fails/degrades/recovers.
        /// </summary>
        [Output("muted")]
        public Output<bool?> Muted { get; private set; } = null!;

        /// <summary>
        /// The name of the check.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// An array of one or more private locations slugs.
        /// </summary>
        [Output("privateLocations")]
        public Output<ImmutableArray<string>> PrivateLocations { get; private set; } = null!;

        /// <summary>
        /// The parameters for the TCP connection.
        /// </summary>
        [Output("request")]
        public Output<Outputs.TcpMonitorRequest> Request { get; private set; } = null!;

        /// <summary>
        /// A strategy for retrying failed check runs.
        /// </summary>
        [Output("retryStrategy")]
        public Output<Outputs.TcpMonitorRetryStrategy> RetryStrategy { get; private set; } = null!;

        /// <summary>
        /// Determines if the check should run in all selected locations in parallel or round-robin.
        /// </summary>
        [Output("runParallel")]
        public Output<bool?> RunParallel { get; private set; } = null!;

        /// <summary>
        /// The ID of the runtime to use for this check.
        /// </summary>
        [Output("runtimeId")]
        public Output<string?> RuntimeId { get; private set; } = null!;

        /// <summary>
        /// Allows to invert the behaviour of when a check is considered to fail.
        /// </summary>
        [Output("shouldFail")]
        public Output<bool?> ShouldFail { get; private set; } = null!;

        /// <summary>
        /// A list of tags for organizing and filtering checks.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// When true, the account level alert settings will be used, not the alert setting defined on this check.
        /// </summary>
        [Output("useGlobalAlertSettings")]
        public Output<bool?> UseGlobalAlertSettings { get; private set; } = null!;


        /// <summary>
        /// Create a TcpMonitor resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public TcpMonitor(string name, TcpMonitorArgs args, CustomResourceOptions? options = null)
            : base("checkly:index/tcpMonitor:TcpMonitor", name, args ?? new TcpMonitorArgs(), MakeResourceOptions(options, ""))
        {
        }

        private TcpMonitor(string name, Input<string> id, TcpMonitorState? state = null, CustomResourceOptions? options = null)
            : base("checkly:index/tcpMonitor:TcpMonitor", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/checkly",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing TcpMonitor resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static TcpMonitor Get(string name, Input<string> id, TcpMonitorState? state = null, CustomResourceOptions? options = null)
        {
            return new TcpMonitor(name, id, state, options);
        }
    }

    public sealed class TcpMonitorArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines if the check is running or not. Possible values `true`, and `false`.
        /// </summary>
        [Input("activated", required: true)]
        public Input<bool> Activated { get; set; } = null!;

        [Input("alertChannelSubscriptions")]
        private InputList<Inputs.TcpMonitorAlertChannelSubscriptionArgs>? _alertChannelSubscriptions;

        /// <summary>
        /// An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        /// </summary>
        public InputList<Inputs.TcpMonitorAlertChannelSubscriptionArgs> AlertChannelSubscriptions
        {
            get => _alertChannelSubscriptions ?? (_alertChannelSubscriptions = new InputList<Inputs.TcpMonitorAlertChannelSubscriptionArgs>());
            set => _alertChannelSubscriptions = value;
        }

        [Input("alertSettings")]
        public Input<Inputs.TcpMonitorAlertSettingsArgs>? AlertSettings { get; set; }

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        /// </summary>
        [Input("degradedResponseTime")]
        public Input<int>? DegradedResponseTime { get; set; }

        /// <summary>
        /// The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        /// </summary>
        [Input("frequency", required: true)]
        public Input<int> Frequency { get; set; } = null!;

        /// <summary>
        /// To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        /// </summary>
        [Input("frequencyOffset")]
        public Input<int>? FrequencyOffset { get; set; }

        /// <summary>
        /// The id of the check group this check is part of.
        /// </summary>
        [Input("groupId")]
        public Input<int>? GroupId { get; set; }

        /// <summary>
        /// The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        /// </summary>
        [Input("groupOrder")]
        public Input<int>? GroupOrder { get; set; }

        [Input("locations")]
        private InputList<string>? _locations;

        /// <summary>
        /// An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        /// </summary>
        public InputList<string> Locations
        {
            get => _locations ?? (_locations = new InputList<string>());
            set => _locations = value;
        }

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        /// </summary>
        [Input("maxResponseTime")]
        public Input<int>? MaxResponseTime { get; set; }

        /// <summary>
        /// Determines if any notifications will be sent out when a check fails/degrades/recovers.
        /// </summary>
        [Input("muted")]
        public Input<bool>? Muted { get; set; }

        /// <summary>
        /// The name of the check.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("privateLocations")]
        private InputList<string>? _privateLocations;

        /// <summary>
        /// An array of one or more private locations slugs.
        /// </summary>
        public InputList<string> PrivateLocations
        {
            get => _privateLocations ?? (_privateLocations = new InputList<string>());
            set => _privateLocations = value;
        }

        /// <summary>
        /// The parameters for the TCP connection.
        /// </summary>
        [Input("request", required: true)]
        public Input<Inputs.TcpMonitorRequestArgs> Request { get; set; } = null!;

        /// <summary>
        /// A strategy for retrying failed check runs.
        /// </summary>
        [Input("retryStrategy")]
        public Input<Inputs.TcpMonitorRetryStrategyArgs>? RetryStrategy { get; set; }

        /// <summary>
        /// Determines if the check should run in all selected locations in parallel or round-robin.
        /// </summary>
        [Input("runParallel")]
        public Input<bool>? RunParallel { get; set; }

        /// <summary>
        /// The ID of the runtime to use for this check.
        /// </summary>
        [Input("runtimeId")]
        public Input<string>? RuntimeId { get; set; }

        /// <summary>
        /// Allows to invert the behaviour of when a check is considered to fail.
        /// </summary>
        [Input("shouldFail")]
        public Input<bool>? ShouldFail { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tags for organizing and filtering checks.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// When true, the account level alert settings will be used, not the alert setting defined on this check.
        /// </summary>
        [Input("useGlobalAlertSettings")]
        public Input<bool>? UseGlobalAlertSettings { get; set; }

        public TcpMonitorArgs()
        {
        }
        public static new TcpMonitorArgs Empty => new TcpMonitorArgs();
    }

    public sealed class TcpMonitorState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines if the check is running or not. Possible values `true`, and `false`.
        /// </summary>
        [Input("activated")]
        public Input<bool>? Activated { get; set; }

        [Input("alertChannelSubscriptions")]
        private InputList<Inputs.TcpMonitorAlertChannelSubscriptionGetArgs>? _alertChannelSubscriptions;

        /// <summary>
        /// An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        /// </summary>
        public InputList<Inputs.TcpMonitorAlertChannelSubscriptionGetArgs> AlertChannelSubscriptions
        {
            get => _alertChannelSubscriptions ?? (_alertChannelSubscriptions = new InputList<Inputs.TcpMonitorAlertChannelSubscriptionGetArgs>());
            set => _alertChannelSubscriptions = value;
        }

        [Input("alertSettings")]
        public Input<Inputs.TcpMonitorAlertSettingsGetArgs>? AlertSettings { get; set; }

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        /// </summary>
        [Input("degradedResponseTime")]
        public Input<int>? DegradedResponseTime { get; set; }

        /// <summary>
        /// The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        /// </summary>
        [Input("frequency")]
        public Input<int>? Frequency { get; set; }

        /// <summary>
        /// To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        /// </summary>
        [Input("frequencyOffset")]
        public Input<int>? FrequencyOffset { get; set; }

        /// <summary>
        /// The id of the check group this check is part of.
        /// </summary>
        [Input("groupId")]
        public Input<int>? GroupId { get; set; }

        /// <summary>
        /// The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        /// </summary>
        [Input("groupOrder")]
        public Input<int>? GroupOrder { get; set; }

        [Input("locations")]
        private InputList<string>? _locations;

        /// <summary>
        /// An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        /// </summary>
        public InputList<string> Locations
        {
            get => _locations ?? (_locations = new InputList<string>());
            set => _locations = value;
        }

        /// <summary>
        /// The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        /// </summary>
        [Input("maxResponseTime")]
        public Input<int>? MaxResponseTime { get; set; }

        /// <summary>
        /// Determines if any notifications will be sent out when a check fails/degrades/recovers.
        /// </summary>
        [Input("muted")]
        public Input<bool>? Muted { get; set; }

        /// <summary>
        /// The name of the check.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("privateLocations")]
        private InputList<string>? _privateLocations;

        /// <summary>
        /// An array of one or more private locations slugs.
        /// </summary>
        public InputList<string> PrivateLocations
        {
            get => _privateLocations ?? (_privateLocations = new InputList<string>());
            set => _privateLocations = value;
        }

        /// <summary>
        /// The parameters for the TCP connection.
        /// </summary>
        [Input("request")]
        public Input<Inputs.TcpMonitorRequestGetArgs>? Request { get; set; }

        /// <summary>
        /// A strategy for retrying failed check runs.
        /// </summary>
        [Input("retryStrategy")]
        public Input<Inputs.TcpMonitorRetryStrategyGetArgs>? RetryStrategy { get; set; }

        /// <summary>
        /// Determines if the check should run in all selected locations in parallel or round-robin.
        /// </summary>
        [Input("runParallel")]
        public Input<bool>? RunParallel { get; set; }

        /// <summary>
        /// The ID of the runtime to use for this check.
        /// </summary>
        [Input("runtimeId")]
        public Input<string>? RuntimeId { get; set; }

        /// <summary>
        /// Allows to invert the behaviour of when a check is considered to fail.
        /// </summary>
        [Input("shouldFail")]
        public Input<bool>? ShouldFail { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tags for organizing and filtering checks.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// When true, the account level alert settings will be used, not the alert setting defined on this check.
        /// </summary>
        [Input("useGlobalAlertSettings")]
        public Input<bool>? UseGlobalAlertSettings { get; set; }

        public TcpMonitorState()
        {
        }
        public static new TcpMonitorState Empty => new TcpMonitorState();
    }
}
