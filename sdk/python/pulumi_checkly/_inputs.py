# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AlertChannelCallArgs',
    'AlertChannelCallArgsDict',
    'AlertChannelEmailArgs',
    'AlertChannelEmailArgsDict',
    'AlertChannelOpsgenieArgs',
    'AlertChannelOpsgenieArgsDict',
    'AlertChannelPagerdutyArgs',
    'AlertChannelPagerdutyArgsDict',
    'AlertChannelSlackArgs',
    'AlertChannelSlackArgsDict',
    'AlertChannelSmsArgs',
    'AlertChannelSmsArgsDict',
    'AlertChannelWebhookArgs',
    'AlertChannelWebhookArgsDict',
    'CheckAlertChannelSubscriptionArgs',
    'CheckAlertChannelSubscriptionArgsDict',
    'CheckAlertSettingsArgs',
    'CheckAlertSettingsArgsDict',
    'CheckAlertSettingsParallelRunFailureThresholdArgs',
    'CheckAlertSettingsParallelRunFailureThresholdArgsDict',
    'CheckAlertSettingsReminderArgs',
    'CheckAlertSettingsReminderArgsDict',
    'CheckAlertSettingsRunBasedEscalationArgs',
    'CheckAlertSettingsRunBasedEscalationArgsDict',
    'CheckAlertSettingsSslCertificateArgs',
    'CheckAlertSettingsSslCertificateArgsDict',
    'CheckAlertSettingsTimeBasedEscalationArgs',
    'CheckAlertSettingsTimeBasedEscalationArgsDict',
    'CheckEnvironmentVariableArgs',
    'CheckEnvironmentVariableArgsDict',
    'CheckGroupAlertChannelSubscriptionArgs',
    'CheckGroupAlertChannelSubscriptionArgsDict',
    'CheckGroupAlertSettingsArgs',
    'CheckGroupAlertSettingsArgsDict',
    'CheckGroupAlertSettingsParallelRunFailureThresholdArgs',
    'CheckGroupAlertSettingsParallelRunFailureThresholdArgsDict',
    'CheckGroupAlertSettingsReminderArgs',
    'CheckGroupAlertSettingsReminderArgsDict',
    'CheckGroupAlertSettingsRunBasedEscalationArgs',
    'CheckGroupAlertSettingsRunBasedEscalationArgsDict',
    'CheckGroupAlertSettingsSslCertificateArgs',
    'CheckGroupAlertSettingsSslCertificateArgsDict',
    'CheckGroupAlertSettingsTimeBasedEscalationArgs',
    'CheckGroupAlertSettingsTimeBasedEscalationArgsDict',
    'CheckGroupApiCheckDefaultsArgs',
    'CheckGroupApiCheckDefaultsArgsDict',
    'CheckGroupApiCheckDefaultsAssertionArgs',
    'CheckGroupApiCheckDefaultsAssertionArgsDict',
    'CheckGroupApiCheckDefaultsBasicAuthArgs',
    'CheckGroupApiCheckDefaultsBasicAuthArgsDict',
    'CheckGroupEnvironmentVariableArgs',
    'CheckGroupEnvironmentVariableArgsDict',
    'CheckGroupRetryStrategyArgs',
    'CheckGroupRetryStrategyArgsDict',
    'CheckRequestArgs',
    'CheckRequestArgsDict',
    'CheckRequestAssertionArgs',
    'CheckRequestAssertionArgsDict',
    'CheckRequestBasicAuthArgs',
    'CheckRequestBasicAuthArgsDict',
    'CheckRetryStrategyArgs',
    'CheckRetryStrategyArgsDict',
    'HeartbeatCheckAlertChannelSubscriptionArgs',
    'HeartbeatCheckAlertChannelSubscriptionArgsDict',
    'HeartbeatCheckAlertSettingsArgs',
    'HeartbeatCheckAlertSettingsArgsDict',
    'HeartbeatCheckAlertSettingsParallelRunFailureThresholdArgs',
    'HeartbeatCheckAlertSettingsParallelRunFailureThresholdArgsDict',
    'HeartbeatCheckAlertSettingsReminderArgs',
    'HeartbeatCheckAlertSettingsReminderArgsDict',
    'HeartbeatCheckAlertSettingsRunBasedEscalationArgs',
    'HeartbeatCheckAlertSettingsRunBasedEscalationArgsDict',
    'HeartbeatCheckAlertSettingsSslCertificateArgs',
    'HeartbeatCheckAlertSettingsSslCertificateArgsDict',
    'HeartbeatCheckAlertSettingsTimeBasedEscalationArgs',
    'HeartbeatCheckAlertSettingsTimeBasedEscalationArgsDict',
    'HeartbeatCheckHeartbeatArgs',
    'HeartbeatCheckHeartbeatArgsDict',
    'TcpCheckAlertChannelSubscriptionArgs',
    'TcpCheckAlertChannelSubscriptionArgsDict',
    'TcpCheckAlertSettingsArgs',
    'TcpCheckAlertSettingsArgsDict',
    'TcpCheckAlertSettingsParallelRunFailureThresholdArgs',
    'TcpCheckAlertSettingsParallelRunFailureThresholdArgsDict',
    'TcpCheckAlertSettingsReminderArgs',
    'TcpCheckAlertSettingsReminderArgsDict',
    'TcpCheckAlertSettingsRunBasedEscalationArgs',
    'TcpCheckAlertSettingsRunBasedEscalationArgsDict',
    'TcpCheckAlertSettingsTimeBasedEscalationArgs',
    'TcpCheckAlertSettingsTimeBasedEscalationArgsDict',
    'TcpCheckRequestArgs',
    'TcpCheckRequestArgsDict',
    'TcpCheckRequestAssertionArgs',
    'TcpCheckRequestAssertionArgsDict',
    'TcpCheckRetryStrategyArgs',
    'TcpCheckRetryStrategyArgsDict',
]

MYPY = False

if not MYPY:
    class AlertChannelCallArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of this alert channel
        """
        number: pulumi.Input[str]
        """
        The mobile number to receive the alerts
        """
elif False:
    AlertChannelCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertChannelCallArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 number: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of this alert channel
        :param pulumi.Input[str] number: The mobile number to receive the alerts
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of this alert channel
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def number(self) -> pulumi.Input[str]:
        """
        The mobile number to receive the alerts
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[str]):
        pulumi.set(self, "number", value)


if not MYPY:
    class AlertChannelEmailArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        The email address of this email alert channel.
        """
elif False:
    AlertChannelEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertChannelEmailArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address: The email address of this email alert channel.
        """
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        The email address of this email alert channel.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)


if not MYPY:
    class AlertChannelOpsgenieArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        name: pulumi.Input[str]
        priority: pulumi.Input[str]
        region: pulumi.Input[str]
elif False:
    AlertChannelOpsgenieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertChannelOpsgenieArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 name: pulumi.Input[str],
                 priority: pulumi.Input[str],
                 region: pulumi.Input[str]):
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[str]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[str]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class AlertChannelPagerdutyArgsDict(TypedDict):
        service_key: pulumi.Input[str]
        account: NotRequired[pulumi.Input[str]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    AlertChannelPagerdutyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertChannelPagerdutyArgs:
    def __init__(__self__, *,
                 service_key: pulumi.Input[str],
                 account: Optional[pulumi.Input[str]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "service_key", service_key)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_key")

    @service_key.setter
    def service_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_key", value)

    @property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class AlertChannelSlackArgsDict(TypedDict):
        channel: pulumi.Input[str]
        """
        The name of the alert's Slack channel
        """
        url: pulumi.Input[str]
        """
        The Slack webhook URL
        """
elif False:
    AlertChannelSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertChannelSlackArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] channel: The name of the alert's Slack channel
        :param pulumi.Input[str] url: The Slack webhook URL
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def channel(self) -> pulumi.Input[str]:
        """
        The name of the alert's Slack channel
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[str]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Slack webhook URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AlertChannelSmsArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of this alert channel
        """
        number: pulumi.Input[str]
        """
        The mobile number to receive the alerts
        """
elif False:
    AlertChannelSmsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertChannelSmsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 number: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of this alert channel
        :param pulumi.Input[str] number: The mobile number to receive the alerts
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of this alert channel
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def number(self) -> pulumi.Input[str]:
        """
        The mobile number to receive the alerts
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[str]):
        pulumi.set(self, "number", value)


if not MYPY:
    class AlertChannelWebhookArgsDict(TypedDict):
        name: pulumi.Input[str]
        url: pulumi.Input[str]
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        method: NotRequired[pulumi.Input[str]]
        """
        (Default `POST`)
        """
        query_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        template: NotRequired[pulumi.Input[str]]
        webhook_secret: NotRequired[pulumi.Input[str]]
        webhook_type: NotRequired[pulumi.Input[str]]
        """
        Type of the webhook. Possible values are 'WEBHOOK*DISCORD', 'WEBHOOK*FIREHYDRANT', 'WEBHOOK*GITLAB*ALERT', 'WEBHOOK*SPIKESH', 'WEBHOOK*SPLUNK', 'WEBHOOK*MSTEAMS' and 'WEBHOOK*TELEGRAM'.
        """
elif False:
    AlertChannelWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertChannelWebhookArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 query_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 template: Optional[pulumi.Input[str]] = None,
                 webhook_secret: Optional[pulumi.Input[str]] = None,
                 webhook_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: (Default `POST`)
        :param pulumi.Input[str] webhook_type: Type of the webhook. Possible values are 'WEBHOOK*DISCORD', 'WEBHOOK*FIREHYDRANT', 'WEBHOOK*GITLAB*ALERT', 'WEBHOOK*SPIKESH', 'WEBHOOK*SPLUNK', 'WEBHOOK*MSTEAMS' and 'WEBHOOK*TELEGRAM'.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if webhook_secret is not None:
            pulumi.set(__self__, "webhook_secret", webhook_secret)
        if webhook_type is not None:
            pulumi.set(__self__, "webhook_type", webhook_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        (Default `POST`)
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "webhook_secret")

    @webhook_secret.setter
    def webhook_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_secret", value)

    @property
    @pulumi.getter(name="webhookType")
    def webhook_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the webhook. Possible values are 'WEBHOOK*DISCORD', 'WEBHOOK*FIREHYDRANT', 'WEBHOOK*GITLAB*ALERT', 'WEBHOOK*SPIKESH', 'WEBHOOK*SPLUNK', 'WEBHOOK*MSTEAMS' and 'WEBHOOK*TELEGRAM'.
        """
        return pulumi.get(self, "webhook_type")

    @webhook_type.setter
    def webhook_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_type", value)


if not MYPY:
    class CheckAlertChannelSubscriptionArgsDict(TypedDict):
        activated: pulumi.Input[bool]
        channel_id: pulumi.Input[int]
elif False:
    CheckAlertChannelSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckAlertChannelSubscriptionArgs:
    def __init__(__self__, *,
                 activated: pulumi.Input[bool],
                 channel_id: pulumi.Input[int]):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @property
    @pulumi.getter
    def activated(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "activated")

    @activated.setter
    def activated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "activated", value)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> pulumi.Input[int]:
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "channel_id", value)


if not MYPY:
    class CheckAlertSettingsArgsDict(TypedDict):
        escalation_type: NotRequired[pulumi.Input[str]]
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        parallel_run_failure_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsParallelRunFailureThresholdArgsDict']]]]
        reminders: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsReminderArgsDict']]]]
        run_based_escalations: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsRunBasedEscalationArgsDict']]]]
        ssl_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsSslCertificateArgsDict']]]]
        time_based_escalations: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsTimeBasedEscalationArgsDict']]]]
elif False:
    CheckAlertSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckAlertSettingsArgs:
    def __init__(__self__, *,
                 escalation_type: Optional[pulumi.Input[str]] = None,
                 parallel_run_failure_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsParallelRunFailureThresholdArgs']]]] = None,
                 reminders: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsReminderArgs']]]] = None,
                 run_based_escalations: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsRunBasedEscalationArgs']]]] = None,
                 ssl_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsSslCertificateArgs']]]] = None,
                 time_based_escalations: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsTimeBasedEscalationArgs']]]] = None):
        """
        :param pulumi.Input[str] escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if ssl_certificates is not None:
            warnings.warn("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""", DeprecationWarning)
            pulumi.log.warn("""ssl_certificates is deprecated: This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
        if ssl_certificates is not None:
            pulumi.set(__self__, "ssl_certificates", ssl_certificates)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[pulumi.Input[str]]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @escalation_type.setter
    def escalation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_type", value)

    @property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsParallelRunFailureThresholdArgs']]]]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @parallel_run_failure_thresholds.setter
    def parallel_run_failure_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsParallelRunFailureThresholdArgs']]]]):
        pulumi.set(self, "parallel_run_failure_thresholds", value)

    @property
    @pulumi.getter
    def reminders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsReminderArgs']]]]:
        return pulumi.get(self, "reminders")

    @reminders.setter
    def reminders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsReminderArgs']]]]):
        pulumi.set(self, "reminders", value)

    @property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsRunBasedEscalationArgs']]]]:
        return pulumi.get(self, "run_based_escalations")

    @run_based_escalations.setter
    def run_based_escalations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsRunBasedEscalationArgs']]]]):
        pulumi.set(self, "run_based_escalations", value)

    @property
    @pulumi.getter(name="sslCertificates")
    @_utilities.deprecated("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
    def ssl_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsSslCertificateArgs']]]]:
        return pulumi.get(self, "ssl_certificates")

    @ssl_certificates.setter
    def ssl_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsSslCertificateArgs']]]]):
        pulumi.set(self, "ssl_certificates", value)

    @property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsTimeBasedEscalationArgs']]]]:
        return pulumi.get(self, "time_based_escalations")

    @time_based_escalations.setter
    def time_based_escalations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckAlertSettingsTimeBasedEscalationArgs']]]]):
        pulumi.set(self, "time_based_escalations", value)


if not MYPY:
    class CheckAlertSettingsParallelRunFailureThresholdArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        percentage: NotRequired[pulumi.Input[int]]
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
elif False:
    CheckAlertSettingsParallelRunFailureThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckAlertSettingsParallelRunFailureThresholdArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param pulumi.Input[int] percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class CheckAlertSettingsReminderArgsDict(TypedDict):
        amount: NotRequired[pulumi.Input[int]]
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        interval: NotRequired[pulumi.Input[int]]
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
elif False:
    CheckAlertSettingsReminderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckAlertSettingsReminderArgs:
    def __init__(__self__, *,
                 amount: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param pulumi.Input[int] interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def amount(self) -> Optional[pulumi.Input[int]]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class CheckAlertSettingsRunBasedEscalationArgsDict(TypedDict):
        failed_run_threshold: NotRequired[pulumi.Input[int]]
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
elif False:
    CheckAlertSettingsRunBasedEscalationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckAlertSettingsRunBasedEscalationArgs:
    def __init__(__self__, *,
                 failed_run_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")

    @failed_run_threshold.setter
    def failed_run_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failed_run_threshold", value)


if not MYPY:
    class CheckAlertSettingsSslCertificateArgsDict(TypedDict):
        alert_threshold: NotRequired[pulumi.Input[int]]
        """
        How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
elif False:
    CheckAlertSettingsSslCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckAlertSettingsSslCertificateArgs:
    def __init__(__self__, *,
                 alert_threshold: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] alert_threshold: How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        :param pulumi.Input[bool] enabled: Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        if alert_threshold is not None:
            pulumi.set(__self__, "alert_threshold", alert_threshold)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="alertThreshold")
    def alert_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        return pulumi.get(self, "alert_threshold")

    @alert_threshold.setter
    def alert_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "alert_threshold", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class CheckAlertSettingsTimeBasedEscalationArgsDict(TypedDict):
        minutes_failing_threshold: NotRequired[pulumi.Input[int]]
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
elif False:
    CheckAlertSettingsTimeBasedEscalationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckAlertSettingsTimeBasedEscalationArgs:
    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")

    @minutes_failing_threshold.setter
    def minutes_failing_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes_failing_threshold", value)


if not MYPY:
    class CheckEnvironmentVariableArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
        locked: NotRequired[pulumi.Input[bool]]
        secret: NotRequired[pulumi.Input[bool]]
elif False:
    CheckEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckEnvironmentVariableArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 locked: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def locked(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "locked")

    @locked.setter
    def locked(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "locked", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class CheckGroupAlertChannelSubscriptionArgsDict(TypedDict):
        activated: pulumi.Input[bool]
        channel_id: pulumi.Input[int]
elif False:
    CheckGroupAlertChannelSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupAlertChannelSubscriptionArgs:
    def __init__(__self__, *,
                 activated: pulumi.Input[bool],
                 channel_id: pulumi.Input[int]):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @property
    @pulumi.getter
    def activated(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "activated")

    @activated.setter
    def activated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "activated", value)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> pulumi.Input[int]:
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "channel_id", value)


if not MYPY:
    class CheckGroupAlertSettingsArgsDict(TypedDict):
        escalation_type: NotRequired[pulumi.Input[str]]
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        parallel_run_failure_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsParallelRunFailureThresholdArgsDict']]]]
        reminders: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsReminderArgsDict']]]]
        run_based_escalations: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsRunBasedEscalationArgsDict']]]]
        ssl_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsSslCertificateArgsDict']]]]
        time_based_escalations: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsTimeBasedEscalationArgsDict']]]]
elif False:
    CheckGroupAlertSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupAlertSettingsArgs:
    def __init__(__self__, *,
                 escalation_type: Optional[pulumi.Input[str]] = None,
                 parallel_run_failure_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsParallelRunFailureThresholdArgs']]]] = None,
                 reminders: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsReminderArgs']]]] = None,
                 run_based_escalations: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsRunBasedEscalationArgs']]]] = None,
                 ssl_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsSslCertificateArgs']]]] = None,
                 time_based_escalations: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsTimeBasedEscalationArgs']]]] = None):
        """
        :param pulumi.Input[str] escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if ssl_certificates is not None:
            warnings.warn("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""", DeprecationWarning)
            pulumi.log.warn("""ssl_certificates is deprecated: This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
        if ssl_certificates is not None:
            pulumi.set(__self__, "ssl_certificates", ssl_certificates)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[pulumi.Input[str]]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @escalation_type.setter
    def escalation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_type", value)

    @property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsParallelRunFailureThresholdArgs']]]]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @parallel_run_failure_thresholds.setter
    def parallel_run_failure_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsParallelRunFailureThresholdArgs']]]]):
        pulumi.set(self, "parallel_run_failure_thresholds", value)

    @property
    @pulumi.getter
    def reminders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsReminderArgs']]]]:
        return pulumi.get(self, "reminders")

    @reminders.setter
    def reminders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsReminderArgs']]]]):
        pulumi.set(self, "reminders", value)

    @property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsRunBasedEscalationArgs']]]]:
        return pulumi.get(self, "run_based_escalations")

    @run_based_escalations.setter
    def run_based_escalations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsRunBasedEscalationArgs']]]]):
        pulumi.set(self, "run_based_escalations", value)

    @property
    @pulumi.getter(name="sslCertificates")
    @_utilities.deprecated("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
    def ssl_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsSslCertificateArgs']]]]:
        return pulumi.get(self, "ssl_certificates")

    @ssl_certificates.setter
    def ssl_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsSslCertificateArgs']]]]):
        pulumi.set(self, "ssl_certificates", value)

    @property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsTimeBasedEscalationArgs']]]]:
        return pulumi.get(self, "time_based_escalations")

    @time_based_escalations.setter
    def time_based_escalations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupAlertSettingsTimeBasedEscalationArgs']]]]):
        pulumi.set(self, "time_based_escalations", value)


if not MYPY:
    class CheckGroupAlertSettingsParallelRunFailureThresholdArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        percentage: NotRequired[pulumi.Input[int]]
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
elif False:
    CheckGroupAlertSettingsParallelRunFailureThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupAlertSettingsParallelRunFailureThresholdArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param pulumi.Input[int] percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class CheckGroupAlertSettingsReminderArgsDict(TypedDict):
        amount: NotRequired[pulumi.Input[int]]
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        interval: NotRequired[pulumi.Input[int]]
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
elif False:
    CheckGroupAlertSettingsReminderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupAlertSettingsReminderArgs:
    def __init__(__self__, *,
                 amount: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param pulumi.Input[int] interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def amount(self) -> Optional[pulumi.Input[int]]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class CheckGroupAlertSettingsRunBasedEscalationArgsDict(TypedDict):
        failed_run_threshold: NotRequired[pulumi.Input[int]]
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
elif False:
    CheckGroupAlertSettingsRunBasedEscalationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupAlertSettingsRunBasedEscalationArgs:
    def __init__(__self__, *,
                 failed_run_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")

    @failed_run_threshold.setter
    def failed_run_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failed_run_threshold", value)


if not MYPY:
    class CheckGroupAlertSettingsSslCertificateArgsDict(TypedDict):
        alert_threshold: NotRequired[pulumi.Input[int]]
        """
        At what moment in time to start alerting on SSL certificates. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines if alert notifications should be sent for expiring SSL certificates.
        """
elif False:
    CheckGroupAlertSettingsSslCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupAlertSettingsSslCertificateArgs:
    def __init__(__self__, *,
                 alert_threshold: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] alert_threshold: At what moment in time to start alerting on SSL certificates. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        :param pulumi.Input[bool] enabled: Determines if alert notifications should be sent for expiring SSL certificates.
        """
        if alert_threshold is not None:
            pulumi.set(__self__, "alert_threshold", alert_threshold)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="alertThreshold")
    def alert_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        At what moment in time to start alerting on SSL certificates. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        return pulumi.get(self, "alert_threshold")

    @alert_threshold.setter
    def alert_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "alert_threshold", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if alert notifications should be sent for expiring SSL certificates.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class CheckGroupAlertSettingsTimeBasedEscalationArgsDict(TypedDict):
        minutes_failing_threshold: NotRequired[pulumi.Input[int]]
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
elif False:
    CheckGroupAlertSettingsTimeBasedEscalationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupAlertSettingsTimeBasedEscalationArgs:
    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")

    @minutes_failing_threshold.setter
    def minutes_failing_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes_failing_threshold", value)


if not MYPY:
    class CheckGroupApiCheckDefaultsArgsDict(TypedDict):
        assertions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckGroupApiCheckDefaultsAssertionArgsDict']]]]
        basic_auth: NotRequired[pulumi.Input['CheckGroupApiCheckDefaultsBasicAuthArgsDict']]
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        query_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        url: NotRequired[pulumi.Input[str]]
        """
        The base url for this group which you can reference with the `GROUP_BASE_URL` variable in all group checks.
        """
elif False:
    CheckGroupApiCheckDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupApiCheckDefaultsArgs:
    def __init__(__self__, *,
                 assertions: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupApiCheckDefaultsAssertionArgs']]]] = None,
                 basic_auth: Optional[pulumi.Input['CheckGroupApiCheckDefaultsBasicAuthArgs']] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 query_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The base url for this group which you can reference with the `GROUP_BASE_URL` variable in all group checks.
        """
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if url is None:
            url = ''
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def assertions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupApiCheckDefaultsAssertionArgs']]]]:
        return pulumi.get(self, "assertions")

    @assertions.setter
    def assertions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckGroupApiCheckDefaultsAssertionArgs']]]]):
        pulumi.set(self, "assertions", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['CheckGroupApiCheckDefaultsBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['CheckGroupApiCheckDefaultsBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The base url for this group which you can reference with the `GROUP_BASE_URL` variable in all group checks.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class CheckGroupApiCheckDefaultsAssertionArgsDict(TypedDict):
        comparison: pulumi.Input[str]
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        source: pulumi.Input[str]
        """
        The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        target: pulumi.Input[str]
        property: NotRequired[pulumi.Input[str]]
elif False:
    CheckGroupApiCheckDefaultsAssertionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupApiCheckDefaultsAssertionArgs:
    def __init__(__self__, *,
                 comparison: pulumi.Input[str],
                 source: pulumi.Input[str],
                 target: pulumi.Input[str],
                 property: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparison: The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        :param pulumi.Input[str] source: The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @property
    @pulumi.getter
    def comparison(self) -> pulumi.Input[str]:
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        return pulumi.get(self, "comparison")

    @comparison.setter
    def comparison(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def property(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property", value)


if not MYPY:
    class CheckGroupApiCheckDefaultsBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    CheckGroupApiCheckDefaultsBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupApiCheckDefaultsBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class CheckGroupEnvironmentVariableArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
        locked: NotRequired[pulumi.Input[bool]]
        secret: NotRequired[pulumi.Input[bool]]
elif False:
    CheckGroupEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupEnvironmentVariableArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 locked: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def locked(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "locked")

    @locked.setter
    def locked(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "locked", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class CheckGroupRetryStrategyArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, or `EXPONENTIAL`.
        """
        base_backoff_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to wait before the first retry attempt.
        """
        max_duration_seconds: NotRequired[pulumi.Input[int]]
        """
        The total amount of time to continue retrying the check (maximum 600 seconds).
        """
        max_retries: NotRequired[pulumi.Input[int]]
        """
        The maximum number of times to retry the check. Value must be between 1 and 10.
        """
        same_region: NotRequired[pulumi.Input[bool]]
        """
        Whether retries should be run in the same region as the initial check run.
        """
elif False:
    CheckGroupRetryStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckGroupRetryStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 base_backoff_seconds: Optional[pulumi.Input[int]] = None,
                 max_duration_seconds: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 same_region: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, or `EXPONENTIAL`.
        :param pulumi.Input[int] base_backoff_seconds: The number of seconds to wait before the first retry attempt.
        :param pulumi.Input[int] max_duration_seconds: The total amount of time to continue retrying the check (maximum 600 seconds).
        :param pulumi.Input[int] max_retries: The maximum number of times to retry the check. Value must be between 1 and 10.
        :param pulumi.Input[bool] same_region: Whether retries should be run in the same region as the initial check run.
        """
        pulumi.set(__self__, "type", type)
        if base_backoff_seconds is not None:
            pulumi.set(__self__, "base_backoff_seconds", base_backoff_seconds)
        if max_duration_seconds is not None:
            pulumi.set(__self__, "max_duration_seconds", max_duration_seconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if same_region is not None:
            pulumi.set(__self__, "same_region", same_region)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, or `EXPONENTIAL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="baseBackoffSeconds")
    def base_backoff_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to wait before the first retry attempt.
        """
        return pulumi.get(self, "base_backoff_seconds")

    @base_backoff_seconds.setter
    def base_backoff_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "base_backoff_seconds", value)

    @property
    @pulumi.getter(name="maxDurationSeconds")
    def max_duration_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The total amount of time to continue retrying the check (maximum 600 seconds).
        """
        return pulumi.get(self, "max_duration_seconds")

    @max_duration_seconds.setter
    def max_duration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_duration_seconds", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of times to retry the check. Value must be between 1 and 10.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="sameRegion")
    def same_region(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether retries should be run in the same region as the initial check run.
        """
        return pulumi.get(self, "same_region")

    @same_region.setter
    def same_region(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "same_region", value)


if not MYPY:
    class CheckRequestArgsDict(TypedDict):
        url: pulumi.Input[str]
        assertions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CheckRequestAssertionArgsDict']]]]
        """
        A request can have multiple assertions.
        """
        basic_auth: NotRequired[pulumi.Input['CheckRequestBasicAuthArgsDict']]
        """
        Set up HTTP basic authentication (username & password).
        """
        body: NotRequired[pulumi.Input[str]]
        """
        The body of the request.
        """
        body_type: NotRequired[pulumi.Input[str]]
        """
        The `Content-Type` header of the request. Possible values `NONE`, `JSON`, `FORM`, `RAW`, and `GRAPHQL`.
        """
        follow_redirects: NotRequired[pulumi.Input[bool]]
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        ip_family: NotRequired[pulumi.Input[str]]
        """
        IP Family to be used when executing the api check. The value can be either IPv4 or IPv6.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The HTTP method to use for this API check. Possible values are `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`. (Default `GET`).
        """
        query_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        skip_ssl: NotRequired[pulumi.Input[bool]]
elif False:
    CheckRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckRequestArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 assertions: Optional[pulumi.Input[Sequence[pulumi.Input['CheckRequestAssertionArgs']]]] = None,
                 basic_auth: Optional[pulumi.Input['CheckRequestBasicAuthArgs']] = None,
                 body: Optional[pulumi.Input[str]] = None,
                 body_type: Optional[pulumi.Input[str]] = None,
                 follow_redirects: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ip_family: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 query_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 skip_ssl: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CheckRequestAssertionArgs']]] assertions: A request can have multiple assertions.
        :param pulumi.Input['CheckRequestBasicAuthArgs'] basic_auth: Set up HTTP basic authentication (username & password).
        :param pulumi.Input[str] body: The body of the request.
        :param pulumi.Input[str] body_type: The `Content-Type` header of the request. Possible values `NONE`, `JSON`, `FORM`, `RAW`, and `GRAPHQL`.
        :param pulumi.Input[str] ip_family: IP Family to be used when executing the api check. The value can be either IPv4 or IPv6.
        :param pulumi.Input[str] method: The HTTP method to use for this API check. Possible values are `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`. (Default `GET`).
        """
        pulumi.set(__self__, "url", url)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if body_type is not None:
            pulumi.set(__self__, "body_type", body_type)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_family is not None:
            pulumi.set(__self__, "ip_family", ip_family)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if skip_ssl is not None:
            pulumi.set(__self__, "skip_ssl", skip_ssl)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def assertions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckRequestAssertionArgs']]]]:
        """
        A request can have multiple assertions.
        """
        return pulumi.get(self, "assertions")

    @assertions.setter
    def assertions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckRequestAssertionArgs']]]]):
        pulumi.set(self, "assertions", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['CheckRequestBasicAuthArgs']]:
        """
        Set up HTTP basic authentication (username & password).
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['CheckRequestBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        The body of the request.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="bodyType")
    def body_type(self) -> Optional[pulumi.Input[str]]:
        """
        The `Content-Type` header of the request. Possible values `NONE`, `JSON`, `FORM`, `RAW`, and `GRAPHQL`.
        """
        return pulumi.get(self, "body_type")

    @body_type.setter
    def body_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_type", value)

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "follow_redirects")

    @follow_redirects.setter
    def follow_redirects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "follow_redirects", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipFamily")
    def ip_family(self) -> Optional[pulumi.Input[str]]:
        """
        IP Family to be used when executing the api check. The value can be either IPv4 or IPv6.
        """
        return pulumi.get(self, "ip_family")

    @ip_family.setter
    def ip_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_family", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use for this API check. Possible values are `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`. (Default `GET`).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter(name="skipSsl")
    def skip_ssl(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "skip_ssl")

    @skip_ssl.setter
    def skip_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_ssl", value)


if not MYPY:
    class CheckRequestAssertionArgsDict(TypedDict):
        comparison: pulumi.Input[str]
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        source: pulumi.Input[str]
        """
        The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        property: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
elif False:
    CheckRequestAssertionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckRequestAssertionArgs:
    def __init__(__self__, *,
                 comparison: pulumi.Input[str],
                 source: pulumi.Input[str],
                 property: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparison: The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        :param pulumi.Input[str] source: The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def comparison(self) -> pulumi.Input[str]:
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        return pulumi.get(self, "comparison")

    @comparison.setter
    def comparison(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def property(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property", value)


if not MYPY:
    class CheckRequestBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    CheckRequestBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckRequestBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class CheckRetryStrategyArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, or `EXPONENTIAL`.
        """
        base_backoff_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to wait before the first retry attempt.
        """
        max_duration_seconds: NotRequired[pulumi.Input[int]]
        """
        The total amount of time to continue retrying the check (maximum 600 seconds).
        """
        max_retries: NotRequired[pulumi.Input[int]]
        """
        The maximum number of times to retry the check. Value must be between 1 and 10.
        """
        same_region: NotRequired[pulumi.Input[bool]]
        """
        Whether retries should be run in the same region as the initial check run.
        """
elif False:
    CheckRetryStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckRetryStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 base_backoff_seconds: Optional[pulumi.Input[int]] = None,
                 max_duration_seconds: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 same_region: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, or `EXPONENTIAL`.
        :param pulumi.Input[int] base_backoff_seconds: The number of seconds to wait before the first retry attempt.
        :param pulumi.Input[int] max_duration_seconds: The total amount of time to continue retrying the check (maximum 600 seconds).
        :param pulumi.Input[int] max_retries: The maximum number of times to retry the check. Value must be between 1 and 10.
        :param pulumi.Input[bool] same_region: Whether retries should be run in the same region as the initial check run.
        """
        pulumi.set(__self__, "type", type)
        if base_backoff_seconds is not None:
            pulumi.set(__self__, "base_backoff_seconds", base_backoff_seconds)
        if max_duration_seconds is not None:
            pulumi.set(__self__, "max_duration_seconds", max_duration_seconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if same_region is not None:
            pulumi.set(__self__, "same_region", same_region)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, or `EXPONENTIAL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="baseBackoffSeconds")
    def base_backoff_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to wait before the first retry attempt.
        """
        return pulumi.get(self, "base_backoff_seconds")

    @base_backoff_seconds.setter
    def base_backoff_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "base_backoff_seconds", value)

    @property
    @pulumi.getter(name="maxDurationSeconds")
    def max_duration_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The total amount of time to continue retrying the check (maximum 600 seconds).
        """
        return pulumi.get(self, "max_duration_seconds")

    @max_duration_seconds.setter
    def max_duration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_duration_seconds", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of times to retry the check. Value must be between 1 and 10.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="sameRegion")
    def same_region(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether retries should be run in the same region as the initial check run.
        """
        return pulumi.get(self, "same_region")

    @same_region.setter
    def same_region(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "same_region", value)


if not MYPY:
    class HeartbeatCheckAlertChannelSubscriptionArgsDict(TypedDict):
        activated: pulumi.Input[bool]
        channel_id: pulumi.Input[int]
elif False:
    HeartbeatCheckAlertChannelSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeartbeatCheckAlertChannelSubscriptionArgs:
    def __init__(__self__, *,
                 activated: pulumi.Input[bool],
                 channel_id: pulumi.Input[int]):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @property
    @pulumi.getter
    def activated(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "activated")

    @activated.setter
    def activated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "activated", value)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> pulumi.Input[int]:
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "channel_id", value)


if not MYPY:
    class HeartbeatCheckAlertSettingsArgsDict(TypedDict):
        escalation_type: NotRequired[pulumi.Input[str]]
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        parallel_run_failure_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsParallelRunFailureThresholdArgsDict']]]]
        reminders: NotRequired[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsReminderArgsDict']]]]
        run_based_escalations: NotRequired[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsRunBasedEscalationArgsDict']]]]
        ssl_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsSslCertificateArgsDict']]]]
        time_based_escalations: NotRequired[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsTimeBasedEscalationArgsDict']]]]
elif False:
    HeartbeatCheckAlertSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeartbeatCheckAlertSettingsArgs:
    def __init__(__self__, *,
                 escalation_type: Optional[pulumi.Input[str]] = None,
                 parallel_run_failure_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsParallelRunFailureThresholdArgs']]]] = None,
                 reminders: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsReminderArgs']]]] = None,
                 run_based_escalations: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsRunBasedEscalationArgs']]]] = None,
                 ssl_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsSslCertificateArgs']]]] = None,
                 time_based_escalations: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsTimeBasedEscalationArgs']]]] = None):
        """
        :param pulumi.Input[str] escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if ssl_certificates is not None:
            warnings.warn("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""", DeprecationWarning)
            pulumi.log.warn("""ssl_certificates is deprecated: This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
        if ssl_certificates is not None:
            pulumi.set(__self__, "ssl_certificates", ssl_certificates)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[pulumi.Input[str]]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @escalation_type.setter
    def escalation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_type", value)

    @property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsParallelRunFailureThresholdArgs']]]]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @parallel_run_failure_thresholds.setter
    def parallel_run_failure_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsParallelRunFailureThresholdArgs']]]]):
        pulumi.set(self, "parallel_run_failure_thresholds", value)

    @property
    @pulumi.getter
    def reminders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsReminderArgs']]]]:
        return pulumi.get(self, "reminders")

    @reminders.setter
    def reminders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsReminderArgs']]]]):
        pulumi.set(self, "reminders", value)

    @property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsRunBasedEscalationArgs']]]]:
        return pulumi.get(self, "run_based_escalations")

    @run_based_escalations.setter
    def run_based_escalations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsRunBasedEscalationArgs']]]]):
        pulumi.set(self, "run_based_escalations", value)

    @property
    @pulumi.getter(name="sslCertificates")
    @_utilities.deprecated("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
    def ssl_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsSslCertificateArgs']]]]:
        return pulumi.get(self, "ssl_certificates")

    @ssl_certificates.setter
    def ssl_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsSslCertificateArgs']]]]):
        pulumi.set(self, "ssl_certificates", value)

    @property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsTimeBasedEscalationArgs']]]]:
        return pulumi.get(self, "time_based_escalations")

    @time_based_escalations.setter
    def time_based_escalations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HeartbeatCheckAlertSettingsTimeBasedEscalationArgs']]]]):
        pulumi.set(self, "time_based_escalations", value)


if not MYPY:
    class HeartbeatCheckAlertSettingsParallelRunFailureThresholdArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        percentage: NotRequired[pulumi.Input[int]]
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
elif False:
    HeartbeatCheckAlertSettingsParallelRunFailureThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeartbeatCheckAlertSettingsParallelRunFailureThresholdArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param pulumi.Input[int] percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class HeartbeatCheckAlertSettingsReminderArgsDict(TypedDict):
        amount: NotRequired[pulumi.Input[int]]
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        interval: NotRequired[pulumi.Input[int]]
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
elif False:
    HeartbeatCheckAlertSettingsReminderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeartbeatCheckAlertSettingsReminderArgs:
    def __init__(__self__, *,
                 amount: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param pulumi.Input[int] interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def amount(self) -> Optional[pulumi.Input[int]]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class HeartbeatCheckAlertSettingsRunBasedEscalationArgsDict(TypedDict):
        failed_run_threshold: NotRequired[pulumi.Input[int]]
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
elif False:
    HeartbeatCheckAlertSettingsRunBasedEscalationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeartbeatCheckAlertSettingsRunBasedEscalationArgs:
    def __init__(__self__, *,
                 failed_run_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")

    @failed_run_threshold.setter
    def failed_run_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failed_run_threshold", value)


if not MYPY:
    class HeartbeatCheckAlertSettingsSslCertificateArgsDict(TypedDict):
        alert_threshold: NotRequired[pulumi.Input[int]]
        """
        How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
elif False:
    HeartbeatCheckAlertSettingsSslCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeartbeatCheckAlertSettingsSslCertificateArgs:
    def __init__(__self__, *,
                 alert_threshold: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] alert_threshold: How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        :param pulumi.Input[bool] enabled: Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        if alert_threshold is not None:
            pulumi.set(__self__, "alert_threshold", alert_threshold)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="alertThreshold")
    def alert_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        return pulumi.get(self, "alert_threshold")

    @alert_threshold.setter
    def alert_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "alert_threshold", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class HeartbeatCheckAlertSettingsTimeBasedEscalationArgsDict(TypedDict):
        minutes_failing_threshold: NotRequired[pulumi.Input[int]]
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
elif False:
    HeartbeatCheckAlertSettingsTimeBasedEscalationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeartbeatCheckAlertSettingsTimeBasedEscalationArgs:
    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")

    @minutes_failing_threshold.setter
    def minutes_failing_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes_failing_threshold", value)


if not MYPY:
    class HeartbeatCheckHeartbeatArgsDict(TypedDict):
        grace: pulumi.Input[int]
        """
        How long Checkly should wait before triggering any alerts when a ping does not arrive within the set period.
        """
        grace_unit: pulumi.Input[str]
        """
        Possible values `seconds`, `minutes`, `hours` and `days`.
        """
        period: pulumi.Input[int]
        """
        How often you expect a ping to the ping URL.
        """
        period_unit: pulumi.Input[str]
        """
        Possible values `seconds`, `minutes`, `hours` and `days`.
        """
        ping_token: NotRequired[pulumi.Input[str]]
        """
        Custom token to generate your ping URL. Checkly will expect a ping to `https://ping.checklyhq.com/[PING_TOKEN]`.
        """
elif False:
    HeartbeatCheckHeartbeatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeartbeatCheckHeartbeatArgs:
    def __init__(__self__, *,
                 grace: pulumi.Input[int],
                 grace_unit: pulumi.Input[str],
                 period: pulumi.Input[int],
                 period_unit: pulumi.Input[str],
                 ping_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] grace: How long Checkly should wait before triggering any alerts when a ping does not arrive within the set period.
        :param pulumi.Input[str] grace_unit: Possible values `seconds`, `minutes`, `hours` and `days`.
        :param pulumi.Input[int] period: How often you expect a ping to the ping URL.
        :param pulumi.Input[str] period_unit: Possible values `seconds`, `minutes`, `hours` and `days`.
        :param pulumi.Input[str] ping_token: Custom token to generate your ping URL. Checkly will expect a ping to `https://ping.checklyhq.com/[PING_TOKEN]`.
        """
        pulumi.set(__self__, "grace", grace)
        pulumi.set(__self__, "grace_unit", grace_unit)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "period_unit", period_unit)
        if ping_token is not None:
            pulumi.set(__self__, "ping_token", ping_token)

    @property
    @pulumi.getter
    def grace(self) -> pulumi.Input[int]:
        """
        How long Checkly should wait before triggering any alerts when a ping does not arrive within the set period.
        """
        return pulumi.get(self, "grace")

    @grace.setter
    def grace(self, value: pulumi.Input[int]):
        pulumi.set(self, "grace", value)

    @property
    @pulumi.getter(name="graceUnit")
    def grace_unit(self) -> pulumi.Input[str]:
        """
        Possible values `seconds`, `minutes`, `hours` and `days`.
        """
        return pulumi.get(self, "grace_unit")

    @grace_unit.setter
    def grace_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "grace_unit", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[int]:
        """
        How often you expect a ping to the ping URL.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[int]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="periodUnit")
    def period_unit(self) -> pulumi.Input[str]:
        """
        Possible values `seconds`, `minutes`, `hours` and `days`.
        """
        return pulumi.get(self, "period_unit")

    @period_unit.setter
    def period_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "period_unit", value)

    @property
    @pulumi.getter(name="pingToken")
    def ping_token(self) -> Optional[pulumi.Input[str]]:
        """
        Custom token to generate your ping URL. Checkly will expect a ping to `https://ping.checklyhq.com/[PING_TOKEN]`.
        """
        return pulumi.get(self, "ping_token")

    @ping_token.setter
    def ping_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ping_token", value)


if not MYPY:
    class TcpCheckAlertChannelSubscriptionArgsDict(TypedDict):
        activated: pulumi.Input[bool]
        channel_id: pulumi.Input[int]
elif False:
    TcpCheckAlertChannelSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpCheckAlertChannelSubscriptionArgs:
    def __init__(__self__, *,
                 activated: pulumi.Input[bool],
                 channel_id: pulumi.Input[int]):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @property
    @pulumi.getter
    def activated(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "activated")

    @activated.setter
    def activated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "activated", value)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> pulumi.Input[int]:
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "channel_id", value)


if not MYPY:
    class TcpCheckAlertSettingsArgsDict(TypedDict):
        escalation_type: NotRequired[pulumi.Input[str]]
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        parallel_run_failure_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsParallelRunFailureThresholdArgsDict']]]]
        reminders: NotRequired[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsReminderArgsDict']]]]
        run_based_escalations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsRunBasedEscalationArgsDict']]]]
        time_based_escalations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsTimeBasedEscalationArgsDict']]]]
elif False:
    TcpCheckAlertSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpCheckAlertSettingsArgs:
    def __init__(__self__, *,
                 escalation_type: Optional[pulumi.Input[str]] = None,
                 parallel_run_failure_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsParallelRunFailureThresholdArgs']]]] = None,
                 reminders: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsReminderArgs']]]] = None,
                 run_based_escalations: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsRunBasedEscalationArgs']]]] = None,
                 time_based_escalations: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsTimeBasedEscalationArgs']]]] = None):
        """
        :param pulumi.Input[str] escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[pulumi.Input[str]]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @escalation_type.setter
    def escalation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_type", value)

    @property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsParallelRunFailureThresholdArgs']]]]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @parallel_run_failure_thresholds.setter
    def parallel_run_failure_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsParallelRunFailureThresholdArgs']]]]):
        pulumi.set(self, "parallel_run_failure_thresholds", value)

    @property
    @pulumi.getter
    def reminders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsReminderArgs']]]]:
        return pulumi.get(self, "reminders")

    @reminders.setter
    def reminders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsReminderArgs']]]]):
        pulumi.set(self, "reminders", value)

    @property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsRunBasedEscalationArgs']]]]:
        return pulumi.get(self, "run_based_escalations")

    @run_based_escalations.setter
    def run_based_escalations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsRunBasedEscalationArgs']]]]):
        pulumi.set(self, "run_based_escalations", value)

    @property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsTimeBasedEscalationArgs']]]]:
        return pulumi.get(self, "time_based_escalations")

    @time_based_escalations.setter
    def time_based_escalations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertSettingsTimeBasedEscalationArgs']]]]):
        pulumi.set(self, "time_based_escalations", value)


if not MYPY:
    class TcpCheckAlertSettingsParallelRunFailureThresholdArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        percentage: NotRequired[pulumi.Input[int]]
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
elif False:
    TcpCheckAlertSettingsParallelRunFailureThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpCheckAlertSettingsParallelRunFailureThresholdArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param pulumi.Input[int] percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class TcpCheckAlertSettingsReminderArgsDict(TypedDict):
        amount: NotRequired[pulumi.Input[int]]
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        interval: NotRequired[pulumi.Input[int]]
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
elif False:
    TcpCheckAlertSettingsReminderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpCheckAlertSettingsReminderArgs:
    def __init__(__self__, *,
                 amount: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param pulumi.Input[int] interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def amount(self) -> Optional[pulumi.Input[int]]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class TcpCheckAlertSettingsRunBasedEscalationArgsDict(TypedDict):
        failed_run_threshold: NotRequired[pulumi.Input[int]]
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
elif False:
    TcpCheckAlertSettingsRunBasedEscalationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpCheckAlertSettingsRunBasedEscalationArgs:
    def __init__(__self__, *,
                 failed_run_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")

    @failed_run_threshold.setter
    def failed_run_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failed_run_threshold", value)


if not MYPY:
    class TcpCheckAlertSettingsTimeBasedEscalationArgsDict(TypedDict):
        minutes_failing_threshold: NotRequired[pulumi.Input[int]]
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
elif False:
    TcpCheckAlertSettingsTimeBasedEscalationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpCheckAlertSettingsTimeBasedEscalationArgs:
    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")

    @minutes_failing_threshold.setter
    def minutes_failing_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes_failing_threshold", value)


if not MYPY:
    class TcpCheckRequestArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        The hostname or IP to connect to. Do not include a scheme or a port in this value.
        """
        port: pulumi.Input[int]
        """
        The port number to connect to.
        """
        assertions: NotRequired[pulumi.Input[Sequence[pulumi.Input['TcpCheckRequestAssertionArgsDict']]]]
        """
        A request can have multiple assertions.
        """
        data: NotRequired[pulumi.Input[str]]
        """
        The data to send to the target host.
        """
        ip_family: NotRequired[pulumi.Input[str]]
        """
        The IP family to use when executing the TCP check. The value can be either `IPv4` or `IPv6`.
        """
elif False:
    TcpCheckRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpCheckRequestArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 port: pulumi.Input[int],
                 assertions: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckRequestAssertionArgs']]]] = None,
                 data: Optional[pulumi.Input[str]] = None,
                 ip_family: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: The hostname or IP to connect to. Do not include a scheme or a port in this value.
        :param pulumi.Input[int] port: The port number to connect to.
        :param pulumi.Input[Sequence[pulumi.Input['TcpCheckRequestAssertionArgs']]] assertions: A request can have multiple assertions.
        :param pulumi.Input[str] data: The data to send to the target host.
        :param pulumi.Input[str] ip_family: The IP family to use when executing the TCP check. The value can be either `IPv4` or `IPv6`.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if ip_family is not None:
            pulumi.set(__self__, "ip_family", ip_family)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        The hostname or IP to connect to. Do not include a scheme or a port in this value.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port number to connect to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def assertions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckRequestAssertionArgs']]]]:
        """
        A request can have multiple assertions.
        """
        return pulumi.get(self, "assertions")

    @assertions.setter
    def assertions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckRequestAssertionArgs']]]]):
        pulumi.set(self, "assertions", value)

    @property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[str]]:
        """
        The data to send to the target host.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data", value)

    @property
    @pulumi.getter(name="ipFamily")
    def ip_family(self) -> Optional[pulumi.Input[str]]:
        """
        The IP family to use when executing the TCP check. The value can be either `IPv4` or `IPv6`.
        """
        return pulumi.get(self, "ip_family")

    @ip_family.setter
    def ip_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_family", value)


if not MYPY:
    class TcpCheckRequestAssertionArgsDict(TypedDict):
        comparison: pulumi.Input[str]
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        source: pulumi.Input[str]
        """
        The source of the asserted value. Possible values are `RESPONSE_DATA` and `RESPONSE_TIME`.
        """
        property: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
elif False:
    TcpCheckRequestAssertionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpCheckRequestAssertionArgs:
    def __init__(__self__, *,
                 comparison: pulumi.Input[str],
                 source: pulumi.Input[str],
                 property: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparison: The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        :param pulumi.Input[str] source: The source of the asserted value. Possible values are `RESPONSE_DATA` and `RESPONSE_TIME`.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def comparison(self) -> pulumi.Input[str]:
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        return pulumi.get(self, "comparison")

    @comparison.setter
    def comparison(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The source of the asserted value. Possible values are `RESPONSE_DATA` and `RESPONSE_TIME`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def property(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property", value)


if not MYPY:
    class TcpCheckRetryStrategyArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, or `EXPONENTIAL`.
        """
        base_backoff_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to wait before the first retry attempt.
        """
        max_duration_seconds: NotRequired[pulumi.Input[int]]
        """
        The total amount of time to continue retrying the check (maximum 600 seconds).
        """
        max_retries: NotRequired[pulumi.Input[int]]
        """
        The maximum number of times to retry the check. Value must be between 1 and 10.
        """
        same_region: NotRequired[pulumi.Input[bool]]
        """
        Whether retries should be run in the same region as the initial check run.
        """
elif False:
    TcpCheckRetryStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpCheckRetryStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 base_backoff_seconds: Optional[pulumi.Input[int]] = None,
                 max_duration_seconds: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 same_region: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, or `EXPONENTIAL`.
        :param pulumi.Input[int] base_backoff_seconds: The number of seconds to wait before the first retry attempt.
        :param pulumi.Input[int] max_duration_seconds: The total amount of time to continue retrying the check (maximum 600 seconds).
        :param pulumi.Input[int] max_retries: The maximum number of times to retry the check. Value must be between 1 and 10.
        :param pulumi.Input[bool] same_region: Whether retries should be run in the same region as the initial check run.
        """
        pulumi.set(__self__, "type", type)
        if base_backoff_seconds is not None:
            pulumi.set(__self__, "base_backoff_seconds", base_backoff_seconds)
        if max_duration_seconds is not None:
            pulumi.set(__self__, "max_duration_seconds", max_duration_seconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if same_region is not None:
            pulumi.set(__self__, "same_region", same_region)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, or `EXPONENTIAL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="baseBackoffSeconds")
    def base_backoff_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to wait before the first retry attempt.
        """
        return pulumi.get(self, "base_backoff_seconds")

    @base_backoff_seconds.setter
    def base_backoff_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "base_backoff_seconds", value)

    @property
    @pulumi.getter(name="maxDurationSeconds")
    def max_duration_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The total amount of time to continue retrying the check (maximum 600 seconds).
        """
        return pulumi.get(self, "max_duration_seconds")

    @max_duration_seconds.setter
    def max_duration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_duration_seconds", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of times to retry the check. Value must be between 1 and 10.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="sameRegion")
    def same_region(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether retries should be run in the same region as the initial check run.
        """
        return pulumi.get(self, "same_region")

    @same_region.setter
    def same_region(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "same_region", value)


