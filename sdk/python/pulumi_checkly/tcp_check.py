# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['TcpCheckArgs', 'TcpCheck']

@pulumi.input_type
class TcpCheckArgs:
    def __init__(__self__, *,
                 activated: pulumi.Input[bool],
                 frequency: pulumi.Input[int],
                 request: pulumi.Input['TcpCheckRequestArgs'],
                 alert_channel_subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertChannelSubscriptionArgs']]]] = None,
                 alert_settings: Optional[pulumi.Input['TcpCheckAlertSettingsArgs']] = None,
                 degraded_response_time: Optional[pulumi.Input[int]] = None,
                 frequency_offset: Optional[pulumi.Input[int]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 group_order: Optional[pulumi.Input[int]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_response_time: Optional[pulumi.Input[int]] = None,
                 muted: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 retry_strategy: Optional[pulumi.Input['TcpCheckRetryStrategyArgs']] = None,
                 run_parallel: Optional[pulumi.Input[bool]] = None,
                 runtime_id: Optional[pulumi.Input[str]] = None,
                 should_fail: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_global_alert_settings: Optional[pulumi.Input[bool]] = None):
        """
        The set of arguments for constructing a TcpCheck resource.
        :param pulumi.Input[bool] activated: Determines if the check is running or not. Possible values `true`, and `false`.
        :param pulumi.Input[int] frequency: The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        :param pulumi.Input['TcpCheckRequestArgs'] request: The parameters for the TCP connection.
        :param pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertChannelSubscriptionArgs']]] alert_channel_subscriptions: An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        :param pulumi.Input[int] degraded_response_time: The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        :param pulumi.Input[int] frequency_offset: To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        :param pulumi.Input[int] group_id: The id of the check group this check is part of.
        :param pulumi.Input[int] group_order: The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        :param pulumi.Input[int] max_response_time: The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        :param pulumi.Input[bool] muted: Determines if any notifications will be sent out when a check fails/degrades/recovers.
        :param pulumi.Input[str] name: The name of the check.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] private_locations: An array of one or more private locations slugs.
        :param pulumi.Input['TcpCheckRetryStrategyArgs'] retry_strategy: A strategy for retrying failed check runs.
        :param pulumi.Input[bool] run_parallel: Determines if the check should run in all selected locations in parallel or round-robin.
        :param pulumi.Input[str] runtime_id: The ID of the runtime to use for this check.
        :param pulumi.Input[bool] should_fail: Allows to invert the behaviour of when a check is considered to fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: A list of tags for organizing and filtering checks.
        :param pulumi.Input[bool] use_global_alert_settings: When true, the account level alert settings will be used, not the alert setting defined on this check.
        """
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "request", request)
        if alert_channel_subscriptions is not None:
            pulumi.set(__self__, "alert_channel_subscriptions", alert_channel_subscriptions)
        if alert_settings is not None:
            pulumi.set(__self__, "alert_settings", alert_settings)
        if degraded_response_time is not None:
            pulumi.set(__self__, "degraded_response_time", degraded_response_time)
        if frequency_offset is not None:
            pulumi.set(__self__, "frequency_offset", frequency_offset)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_order is not None:
            pulumi.set(__self__, "group_order", group_order)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if max_response_time is not None:
            pulumi.set(__self__, "max_response_time", max_response_time)
        if muted is not None:
            pulumi.set(__self__, "muted", muted)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_locations is not None:
            pulumi.set(__self__, "private_locations", private_locations)
        if retry_strategy is not None:
            pulumi.set(__self__, "retry_strategy", retry_strategy)
        if run_parallel is not None:
            pulumi.set(__self__, "run_parallel", run_parallel)
        if runtime_id is not None:
            pulumi.set(__self__, "runtime_id", runtime_id)
        if should_fail is not None:
            pulumi.set(__self__, "should_fail", should_fail)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_global_alert_settings is not None:
            pulumi.set(__self__, "use_global_alert_settings", use_global_alert_settings)

    @property
    @pulumi.getter
    def activated(self) -> pulumi.Input[bool]:
        """
        Determines if the check is running or not. Possible values `true`, and `false`.
        """
        return pulumi.get(self, "activated")

    @activated.setter
    def activated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "activated", value)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[int]:
        """
        The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def request(self) -> pulumi.Input['TcpCheckRequestArgs']:
        """
        The parameters for the TCP connection.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: pulumi.Input['TcpCheckRequestArgs']):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter(name="alertChannelSubscriptions")
    def alert_channel_subscriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertChannelSubscriptionArgs']]]]:
        """
        An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        """
        return pulumi.get(self, "alert_channel_subscriptions")

    @alert_channel_subscriptions.setter
    def alert_channel_subscriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertChannelSubscriptionArgs']]]]):
        pulumi.set(self, "alert_channel_subscriptions", value)

    @property
    @pulumi.getter(name="alertSettings")
    def alert_settings(self) -> Optional[pulumi.Input['TcpCheckAlertSettingsArgs']]:
        return pulumi.get(self, "alert_settings")

    @alert_settings.setter
    def alert_settings(self, value: Optional[pulumi.Input['TcpCheckAlertSettingsArgs']]):
        pulumi.set(self, "alert_settings", value)

    @property
    @pulumi.getter(name="degradedResponseTime")
    def degraded_response_time(self) -> Optional[pulumi.Input[int]]:
        """
        The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        """
        return pulumi.get(self, "degraded_response_time")

    @degraded_response_time.setter
    def degraded_response_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "degraded_response_time", value)

    @property
    @pulumi.getter(name="frequencyOffset")
    def frequency_offset(self) -> Optional[pulumi.Input[int]]:
        """
        To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        """
        return pulumi.get(self, "frequency_offset")

    @frequency_offset.setter
    def frequency_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frequency_offset", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The id of the check group this check is part of.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="groupOrder")
    def group_order(self) -> Optional[pulumi.Input[int]]:
        """
        The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        """
        return pulumi.get(self, "group_order")

    @group_order.setter
    def group_order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_order", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="maxResponseTime")
    def max_response_time(self) -> Optional[pulumi.Input[int]]:
        """
        The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        """
        return pulumi.get(self, "max_response_time")

    @max_response_time.setter
    def max_response_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_response_time", value)

    @property
    @pulumi.getter
    def muted(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if any notifications will be sent out when a check fails/degrades/recovers.
        """
        return pulumi.get(self, "muted")

    @muted.setter
    def muted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "muted", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the check.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateLocations")
    def private_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of one or more private locations slugs.
        """
        return pulumi.get(self, "private_locations")

    @private_locations.setter
    def private_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "private_locations", value)

    @property
    @pulumi.getter(name="retryStrategy")
    def retry_strategy(self) -> Optional[pulumi.Input['TcpCheckRetryStrategyArgs']]:
        """
        A strategy for retrying failed check runs.
        """
        return pulumi.get(self, "retry_strategy")

    @retry_strategy.setter
    def retry_strategy(self, value: Optional[pulumi.Input['TcpCheckRetryStrategyArgs']]):
        pulumi.set(self, "retry_strategy", value)

    @property
    @pulumi.getter(name="runParallel")
    def run_parallel(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if the check should run in all selected locations in parallel or round-robin.
        """
        return pulumi.get(self, "run_parallel")

    @run_parallel.setter
    def run_parallel(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_parallel", value)

    @property
    @pulumi.getter(name="runtimeId")
    def runtime_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the runtime to use for this check.
        """
        return pulumi.get(self, "runtime_id")

    @runtime_id.setter
    def runtime_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_id", value)

    @property
    @pulumi.getter(name="shouldFail")
    def should_fail(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows to invert the behaviour of when a check is considered to fail.
        """
        return pulumi.get(self, "should_fail")

    @should_fail.setter
    def should_fail(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_fail", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of tags for organizing and filtering checks.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="useGlobalAlertSettings")
    def use_global_alert_settings(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the account level alert settings will be used, not the alert setting defined on this check.
        """
        return pulumi.get(self, "use_global_alert_settings")

    @use_global_alert_settings.setter
    def use_global_alert_settings(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_global_alert_settings", value)


@pulumi.input_type
class _TcpCheckState:
    def __init__(__self__, *,
                 activated: Optional[pulumi.Input[bool]] = None,
                 alert_channel_subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertChannelSubscriptionArgs']]]] = None,
                 alert_settings: Optional[pulumi.Input['TcpCheckAlertSettingsArgs']] = None,
                 degraded_response_time: Optional[pulumi.Input[int]] = None,
                 frequency: Optional[pulumi.Input[int]] = None,
                 frequency_offset: Optional[pulumi.Input[int]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 group_order: Optional[pulumi.Input[int]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_response_time: Optional[pulumi.Input[int]] = None,
                 muted: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 request: Optional[pulumi.Input['TcpCheckRequestArgs']] = None,
                 retry_strategy: Optional[pulumi.Input['TcpCheckRetryStrategyArgs']] = None,
                 run_parallel: Optional[pulumi.Input[bool]] = None,
                 runtime_id: Optional[pulumi.Input[str]] = None,
                 should_fail: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_global_alert_settings: Optional[pulumi.Input[bool]] = None):
        """
        Input properties used for looking up and filtering TcpCheck resources.
        :param pulumi.Input[bool] activated: Determines if the check is running or not. Possible values `true`, and `false`.
        :param pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertChannelSubscriptionArgs']]] alert_channel_subscriptions: An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        :param pulumi.Input[int] degraded_response_time: The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        :param pulumi.Input[int] frequency: The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        :param pulumi.Input[int] frequency_offset: To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        :param pulumi.Input[int] group_id: The id of the check group this check is part of.
        :param pulumi.Input[int] group_order: The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        :param pulumi.Input[int] max_response_time: The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        :param pulumi.Input[bool] muted: Determines if any notifications will be sent out when a check fails/degrades/recovers.
        :param pulumi.Input[str] name: The name of the check.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] private_locations: An array of one or more private locations slugs.
        :param pulumi.Input['TcpCheckRequestArgs'] request: The parameters for the TCP connection.
        :param pulumi.Input['TcpCheckRetryStrategyArgs'] retry_strategy: A strategy for retrying failed check runs.
        :param pulumi.Input[bool] run_parallel: Determines if the check should run in all selected locations in parallel or round-robin.
        :param pulumi.Input[str] runtime_id: The ID of the runtime to use for this check.
        :param pulumi.Input[bool] should_fail: Allows to invert the behaviour of when a check is considered to fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: A list of tags for organizing and filtering checks.
        :param pulumi.Input[bool] use_global_alert_settings: When true, the account level alert settings will be used, not the alert setting defined on this check.
        """
        if activated is not None:
            pulumi.set(__self__, "activated", activated)
        if alert_channel_subscriptions is not None:
            pulumi.set(__self__, "alert_channel_subscriptions", alert_channel_subscriptions)
        if alert_settings is not None:
            pulumi.set(__self__, "alert_settings", alert_settings)
        if degraded_response_time is not None:
            pulumi.set(__self__, "degraded_response_time", degraded_response_time)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if frequency_offset is not None:
            pulumi.set(__self__, "frequency_offset", frequency_offset)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_order is not None:
            pulumi.set(__self__, "group_order", group_order)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if max_response_time is not None:
            pulumi.set(__self__, "max_response_time", max_response_time)
        if muted is not None:
            pulumi.set(__self__, "muted", muted)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_locations is not None:
            pulumi.set(__self__, "private_locations", private_locations)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if retry_strategy is not None:
            pulumi.set(__self__, "retry_strategy", retry_strategy)
        if run_parallel is not None:
            pulumi.set(__self__, "run_parallel", run_parallel)
        if runtime_id is not None:
            pulumi.set(__self__, "runtime_id", runtime_id)
        if should_fail is not None:
            pulumi.set(__self__, "should_fail", should_fail)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_global_alert_settings is not None:
            pulumi.set(__self__, "use_global_alert_settings", use_global_alert_settings)

    @property
    @pulumi.getter
    def activated(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if the check is running or not. Possible values `true`, and `false`.
        """
        return pulumi.get(self, "activated")

    @activated.setter
    def activated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "activated", value)

    @property
    @pulumi.getter(name="alertChannelSubscriptions")
    def alert_channel_subscriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertChannelSubscriptionArgs']]]]:
        """
        An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        """
        return pulumi.get(self, "alert_channel_subscriptions")

    @alert_channel_subscriptions.setter
    def alert_channel_subscriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TcpCheckAlertChannelSubscriptionArgs']]]]):
        pulumi.set(self, "alert_channel_subscriptions", value)

    @property
    @pulumi.getter(name="alertSettings")
    def alert_settings(self) -> Optional[pulumi.Input['TcpCheckAlertSettingsArgs']]:
        return pulumi.get(self, "alert_settings")

    @alert_settings.setter
    def alert_settings(self, value: Optional[pulumi.Input['TcpCheckAlertSettingsArgs']]):
        pulumi.set(self, "alert_settings", value)

    @property
    @pulumi.getter(name="degradedResponseTime")
    def degraded_response_time(self) -> Optional[pulumi.Input[int]]:
        """
        The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        """
        return pulumi.get(self, "degraded_response_time")

    @degraded_response_time.setter
    def degraded_response_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "degraded_response_time", value)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[int]]:
        """
        The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="frequencyOffset")
    def frequency_offset(self) -> Optional[pulumi.Input[int]]:
        """
        To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        """
        return pulumi.get(self, "frequency_offset")

    @frequency_offset.setter
    def frequency_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frequency_offset", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The id of the check group this check is part of.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="groupOrder")
    def group_order(self) -> Optional[pulumi.Input[int]]:
        """
        The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        """
        return pulumi.get(self, "group_order")

    @group_order.setter
    def group_order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_order", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="maxResponseTime")
    def max_response_time(self) -> Optional[pulumi.Input[int]]:
        """
        The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        """
        return pulumi.get(self, "max_response_time")

    @max_response_time.setter
    def max_response_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_response_time", value)

    @property
    @pulumi.getter
    def muted(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if any notifications will be sent out when a check fails/degrades/recovers.
        """
        return pulumi.get(self, "muted")

    @muted.setter
    def muted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "muted", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the check.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateLocations")
    def private_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of one or more private locations slugs.
        """
        return pulumi.get(self, "private_locations")

    @private_locations.setter
    def private_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "private_locations", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['TcpCheckRequestArgs']]:
        """
        The parameters for the TCP connection.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['TcpCheckRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter(name="retryStrategy")
    def retry_strategy(self) -> Optional[pulumi.Input['TcpCheckRetryStrategyArgs']]:
        """
        A strategy for retrying failed check runs.
        """
        return pulumi.get(self, "retry_strategy")

    @retry_strategy.setter
    def retry_strategy(self, value: Optional[pulumi.Input['TcpCheckRetryStrategyArgs']]):
        pulumi.set(self, "retry_strategy", value)

    @property
    @pulumi.getter(name="runParallel")
    def run_parallel(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if the check should run in all selected locations in parallel or round-robin.
        """
        return pulumi.get(self, "run_parallel")

    @run_parallel.setter
    def run_parallel(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_parallel", value)

    @property
    @pulumi.getter(name="runtimeId")
    def runtime_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the runtime to use for this check.
        """
        return pulumi.get(self, "runtime_id")

    @runtime_id.setter
    def runtime_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_id", value)

    @property
    @pulumi.getter(name="shouldFail")
    def should_fail(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows to invert the behaviour of when a check is considered to fail.
        """
        return pulumi.get(self, "should_fail")

    @should_fail.setter
    def should_fail(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_fail", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of tags for organizing and filtering checks.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="useGlobalAlertSettings")
    def use_global_alert_settings(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the account level alert settings will be used, not the alert setting defined on this check.
        """
        return pulumi.get(self, "use_global_alert_settings")

    @use_global_alert_settings.setter
    def use_global_alert_settings(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_global_alert_settings", value)


class TcpCheck(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 activated: Optional[pulumi.Input[bool]] = None,
                 alert_channel_subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TcpCheckAlertChannelSubscriptionArgs', 'TcpCheckAlertChannelSubscriptionArgsDict']]]]] = None,
                 alert_settings: Optional[pulumi.Input[Union['TcpCheckAlertSettingsArgs', 'TcpCheckAlertSettingsArgsDict']]] = None,
                 degraded_response_time: Optional[pulumi.Input[int]] = None,
                 frequency: Optional[pulumi.Input[int]] = None,
                 frequency_offset: Optional[pulumi.Input[int]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 group_order: Optional[pulumi.Input[int]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_response_time: Optional[pulumi.Input[int]] = None,
                 muted: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 request: Optional[pulumi.Input[Union['TcpCheckRequestArgs', 'TcpCheckRequestArgsDict']]] = None,
                 retry_strategy: Optional[pulumi.Input[Union['TcpCheckRetryStrategyArgs', 'TcpCheckRetryStrategyArgsDict']]] = None,
                 run_parallel: Optional[pulumi.Input[bool]] = None,
                 runtime_id: Optional[pulumi.Input[str]] = None,
                 should_fail: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_global_alert_settings: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        """
        TCP checks allow you to monitor remote endpoints at a lower level.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_checkly as checkly

        # Basic TCP Check
        example_tcp_check = checkly.TcpCheck("example-tcp-check",
            name="Example TCP check",
            activated=True,
            should_fail=False,
            frequency=1,
            use_global_alert_settings=True,
            locations=["us-west-1"],
            request={
                "hostname": "api.checklyhq.com",
                "port": 80,
            })
        # A more complex example using assertions and setting alerts
        example_tcp_check_2 = checkly.TcpCheck("example-tcp-check-2",
            name="Example TCP check 2",
            activated=True,
            should_fail=True,
            frequency=1,
            degraded_response_time=5000,
            max_response_time=10000,
            locations=[
                "us-west-1",
                "ap-northeast-1",
                "ap-south-1",
            ],
            alert_settings={
                "escalation_type": "RUN_BASED",
                "run_based_escalations": [{
                    "failed_run_threshold": 1,
                }],
                "reminders": [{
                    "amount": 1,
                }],
            },
            retry_strategy={
                "type": "FIXED",
                "base_backoff_seconds": 60,
                "max_duration_seconds": 600,
                "max_retries": 3,
                "same_region": False,
            },
            request={
                "hostname": "api.checklyhq.com",
                "port": 80,
                "data": "hello",
                "assertions": [
                    {
                        "source": "RESPONSE_DATA",
                        "property": "",
                        "comparison": "CONTAINS",
                        "target": "welcome",
                    },
                    {
                        "source": "RESPONSE_TIME",
                        "property": "",
                        "comparison": "LESS_THAN",
                        "target": "2000",
                    },
                ],
            })
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] activated: Determines if the check is running or not. Possible values `true`, and `false`.
        :param pulumi.Input[Sequence[pulumi.Input[Union['TcpCheckAlertChannelSubscriptionArgs', 'TcpCheckAlertChannelSubscriptionArgsDict']]]] alert_channel_subscriptions: An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        :param pulumi.Input[int] degraded_response_time: The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        :param pulumi.Input[int] frequency: The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        :param pulumi.Input[int] frequency_offset: To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        :param pulumi.Input[int] group_id: The id of the check group this check is part of.
        :param pulumi.Input[int] group_order: The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        :param pulumi.Input[int] max_response_time: The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        :param pulumi.Input[bool] muted: Determines if any notifications will be sent out when a check fails/degrades/recovers.
        :param pulumi.Input[str] name: The name of the check.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] private_locations: An array of one or more private locations slugs.
        :param pulumi.Input[Union['TcpCheckRequestArgs', 'TcpCheckRequestArgsDict']] request: The parameters for the TCP connection.
        :param pulumi.Input[Union['TcpCheckRetryStrategyArgs', 'TcpCheckRetryStrategyArgsDict']] retry_strategy: A strategy for retrying failed check runs.
        :param pulumi.Input[bool] run_parallel: Determines if the check should run in all selected locations in parallel or round-robin.
        :param pulumi.Input[str] runtime_id: The ID of the runtime to use for this check.
        :param pulumi.Input[bool] should_fail: Allows to invert the behaviour of when a check is considered to fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: A list of tags for organizing and filtering checks.
        :param pulumi.Input[bool] use_global_alert_settings: When true, the account level alert settings will be used, not the alert setting defined on this check.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: TcpCheckArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        TCP checks allow you to monitor remote endpoints at a lower level.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_checkly as checkly

        # Basic TCP Check
        example_tcp_check = checkly.TcpCheck("example-tcp-check",
            name="Example TCP check",
            activated=True,
            should_fail=False,
            frequency=1,
            use_global_alert_settings=True,
            locations=["us-west-1"],
            request={
                "hostname": "api.checklyhq.com",
                "port": 80,
            })
        # A more complex example using assertions and setting alerts
        example_tcp_check_2 = checkly.TcpCheck("example-tcp-check-2",
            name="Example TCP check 2",
            activated=True,
            should_fail=True,
            frequency=1,
            degraded_response_time=5000,
            max_response_time=10000,
            locations=[
                "us-west-1",
                "ap-northeast-1",
                "ap-south-1",
            ],
            alert_settings={
                "escalation_type": "RUN_BASED",
                "run_based_escalations": [{
                    "failed_run_threshold": 1,
                }],
                "reminders": [{
                    "amount": 1,
                }],
            },
            retry_strategy={
                "type": "FIXED",
                "base_backoff_seconds": 60,
                "max_duration_seconds": 600,
                "max_retries": 3,
                "same_region": False,
            },
            request={
                "hostname": "api.checklyhq.com",
                "port": 80,
                "data": "hello",
                "assertions": [
                    {
                        "source": "RESPONSE_DATA",
                        "property": "",
                        "comparison": "CONTAINS",
                        "target": "welcome",
                    },
                    {
                        "source": "RESPONSE_TIME",
                        "property": "",
                        "comparison": "LESS_THAN",
                        "target": "2000",
                    },
                ],
            })
        ```

        :param str resource_name: The name of the resource.
        :param TcpCheckArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(TcpCheckArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 activated: Optional[pulumi.Input[bool]] = None,
                 alert_channel_subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TcpCheckAlertChannelSubscriptionArgs', 'TcpCheckAlertChannelSubscriptionArgsDict']]]]] = None,
                 alert_settings: Optional[pulumi.Input[Union['TcpCheckAlertSettingsArgs', 'TcpCheckAlertSettingsArgsDict']]] = None,
                 degraded_response_time: Optional[pulumi.Input[int]] = None,
                 frequency: Optional[pulumi.Input[int]] = None,
                 frequency_offset: Optional[pulumi.Input[int]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 group_order: Optional[pulumi.Input[int]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_response_time: Optional[pulumi.Input[int]] = None,
                 muted: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 request: Optional[pulumi.Input[Union['TcpCheckRequestArgs', 'TcpCheckRequestArgsDict']]] = None,
                 retry_strategy: Optional[pulumi.Input[Union['TcpCheckRetryStrategyArgs', 'TcpCheckRetryStrategyArgsDict']]] = None,
                 run_parallel: Optional[pulumi.Input[bool]] = None,
                 runtime_id: Optional[pulumi.Input[str]] = None,
                 should_fail: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_global_alert_settings: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = TcpCheckArgs.__new__(TcpCheckArgs)

            if activated is None and not opts.urn:
                raise TypeError("Missing required property 'activated'")
            __props__.__dict__["activated"] = activated
            __props__.__dict__["alert_channel_subscriptions"] = alert_channel_subscriptions
            __props__.__dict__["alert_settings"] = alert_settings
            __props__.__dict__["degraded_response_time"] = degraded_response_time
            if frequency is None and not opts.urn:
                raise TypeError("Missing required property 'frequency'")
            __props__.__dict__["frequency"] = frequency
            __props__.__dict__["frequency_offset"] = frequency_offset
            __props__.__dict__["group_id"] = group_id
            __props__.__dict__["group_order"] = group_order
            __props__.__dict__["locations"] = locations
            __props__.__dict__["max_response_time"] = max_response_time
            __props__.__dict__["muted"] = muted
            __props__.__dict__["name"] = name
            __props__.__dict__["private_locations"] = private_locations
            if request is None and not opts.urn:
                raise TypeError("Missing required property 'request'")
            __props__.__dict__["request"] = request
            __props__.__dict__["retry_strategy"] = retry_strategy
            __props__.__dict__["run_parallel"] = run_parallel
            __props__.__dict__["runtime_id"] = runtime_id
            __props__.__dict__["should_fail"] = should_fail
            __props__.__dict__["tags"] = tags
            __props__.__dict__["use_global_alert_settings"] = use_global_alert_settings
        super(TcpCheck, __self__).__init__(
            'checkly:index/tcpCheck:TcpCheck',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            activated: Optional[pulumi.Input[bool]] = None,
            alert_channel_subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TcpCheckAlertChannelSubscriptionArgs', 'TcpCheckAlertChannelSubscriptionArgsDict']]]]] = None,
            alert_settings: Optional[pulumi.Input[Union['TcpCheckAlertSettingsArgs', 'TcpCheckAlertSettingsArgsDict']]] = None,
            degraded_response_time: Optional[pulumi.Input[int]] = None,
            frequency: Optional[pulumi.Input[int]] = None,
            frequency_offset: Optional[pulumi.Input[int]] = None,
            group_id: Optional[pulumi.Input[int]] = None,
            group_order: Optional[pulumi.Input[int]] = None,
            locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            max_response_time: Optional[pulumi.Input[int]] = None,
            muted: Optional[pulumi.Input[bool]] = None,
            name: Optional[pulumi.Input[str]] = None,
            private_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            request: Optional[pulumi.Input[Union['TcpCheckRequestArgs', 'TcpCheckRequestArgsDict']]] = None,
            retry_strategy: Optional[pulumi.Input[Union['TcpCheckRetryStrategyArgs', 'TcpCheckRetryStrategyArgsDict']]] = None,
            run_parallel: Optional[pulumi.Input[bool]] = None,
            runtime_id: Optional[pulumi.Input[str]] = None,
            should_fail: Optional[pulumi.Input[bool]] = None,
            tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            use_global_alert_settings: Optional[pulumi.Input[bool]] = None) -> 'TcpCheck':
        """
        Get an existing TcpCheck resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] activated: Determines if the check is running or not. Possible values `true`, and `false`.
        :param pulumi.Input[Sequence[pulumi.Input[Union['TcpCheckAlertChannelSubscriptionArgs', 'TcpCheckAlertChannelSubscriptionArgsDict']]]] alert_channel_subscriptions: An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        :param pulumi.Input[int] degraded_response_time: The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        :param pulumi.Input[int] frequency: The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        :param pulumi.Input[int] frequency_offset: To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        :param pulumi.Input[int] group_id: The id of the check group this check is part of.
        :param pulumi.Input[int] group_order: The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        :param pulumi.Input[int] max_response_time: The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        :param pulumi.Input[bool] muted: Determines if any notifications will be sent out when a check fails/degrades/recovers.
        :param pulumi.Input[str] name: The name of the check.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] private_locations: An array of one or more private locations slugs.
        :param pulumi.Input[Union['TcpCheckRequestArgs', 'TcpCheckRequestArgsDict']] request: The parameters for the TCP connection.
        :param pulumi.Input[Union['TcpCheckRetryStrategyArgs', 'TcpCheckRetryStrategyArgsDict']] retry_strategy: A strategy for retrying failed check runs.
        :param pulumi.Input[bool] run_parallel: Determines if the check should run in all selected locations in parallel or round-robin.
        :param pulumi.Input[str] runtime_id: The ID of the runtime to use for this check.
        :param pulumi.Input[bool] should_fail: Allows to invert the behaviour of when a check is considered to fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: A list of tags for organizing and filtering checks.
        :param pulumi.Input[bool] use_global_alert_settings: When true, the account level alert settings will be used, not the alert setting defined on this check.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _TcpCheckState.__new__(_TcpCheckState)

        __props__.__dict__["activated"] = activated
        __props__.__dict__["alert_channel_subscriptions"] = alert_channel_subscriptions
        __props__.__dict__["alert_settings"] = alert_settings
        __props__.__dict__["degraded_response_time"] = degraded_response_time
        __props__.__dict__["frequency"] = frequency
        __props__.__dict__["frequency_offset"] = frequency_offset
        __props__.__dict__["group_id"] = group_id
        __props__.__dict__["group_order"] = group_order
        __props__.__dict__["locations"] = locations
        __props__.__dict__["max_response_time"] = max_response_time
        __props__.__dict__["muted"] = muted
        __props__.__dict__["name"] = name
        __props__.__dict__["private_locations"] = private_locations
        __props__.__dict__["request"] = request
        __props__.__dict__["retry_strategy"] = retry_strategy
        __props__.__dict__["run_parallel"] = run_parallel
        __props__.__dict__["runtime_id"] = runtime_id
        __props__.__dict__["should_fail"] = should_fail
        __props__.__dict__["tags"] = tags
        __props__.__dict__["use_global_alert_settings"] = use_global_alert_settings
        return TcpCheck(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def activated(self) -> pulumi.Output[bool]:
        """
        Determines if the check is running or not. Possible values `true`, and `false`.
        """
        return pulumi.get(self, "activated")

    @property
    @pulumi.getter(name="alertChannelSubscriptions")
    def alert_channel_subscriptions(self) -> pulumi.Output[Optional[Sequence['outputs.TcpCheckAlertChannelSubscription']]]:
        """
        An array of channel IDs and whether they're activated or not. If you don't set at least one alert subscription for your check, we won't be able to alert you in case something goes wrong with it.
        """
        return pulumi.get(self, "alert_channel_subscriptions")

    @property
    @pulumi.getter(name="alertSettings")
    def alert_settings(self) -> pulumi.Output['outputs.TcpCheckAlertSettings']:
        return pulumi.get(self, "alert_settings")

    @property
    @pulumi.getter(name="degradedResponseTime")
    def degraded_response_time(self) -> pulumi.Output[Optional[int]]:
        """
        The response time in milliseconds starting from which a check should be considered degraded. Possible values are between 0 and 5000. (Default `4000`).
        """
        return pulumi.get(self, "degraded_response_time")

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Output[int]:
        """
        The frequency in minutes to run the check. Possible values are `0`, `1`, `2`, `5`, `10`, `15`, `30`, `60`, `120`, `180`, `360`, `720`, and `1440`.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="frequencyOffset")
    def frequency_offset(self) -> pulumi.Output[Optional[int]]:
        """
        To create a high frequency check, the property `frequency` must be `0` and `frequency_offset` can be `10`, `20` or `30`.
        """
        return pulumi.get(self, "frequency_offset")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Output[Optional[int]]:
        """
        The id of the check group this check is part of.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupOrder")
    def group_order(self) -> pulumi.Output[Optional[int]]:
        """
        The position of this check in a check group. It determines in what order checks are run when a group is triggered from the API or from CI/CD.
        """
        return pulumi.get(self, "group_order")

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        An array of one or more data center locations where to run the this check. (Default ["us-east-1"])
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="maxResponseTime")
    def max_response_time(self) -> pulumi.Output[Optional[int]]:
        """
        The response time in milliseconds starting from which a check should be considered failing. Possible values are between 0 and 5000. (Default `5000`).
        """
        return pulumi.get(self, "max_response_time")

    @property
    @pulumi.getter
    def muted(self) -> pulumi.Output[Optional[bool]]:
        """
        Determines if any notifications will be sent out when a check fails/degrades/recovers.
        """
        return pulumi.get(self, "muted")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        The name of the check.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLocations")
    def private_locations(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        An array of one or more private locations slugs.
        """
        return pulumi.get(self, "private_locations")

    @property
    @pulumi.getter
    def request(self) -> pulumi.Output['outputs.TcpCheckRequest']:
        """
        The parameters for the TCP connection.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter(name="retryStrategy")
    def retry_strategy(self) -> pulumi.Output['outputs.TcpCheckRetryStrategy']:
        """
        A strategy for retrying failed check runs.
        """
        return pulumi.get(self, "retry_strategy")

    @property
    @pulumi.getter(name="runParallel")
    def run_parallel(self) -> pulumi.Output[Optional[bool]]:
        """
        Determines if the check should run in all selected locations in parallel or round-robin.
        """
        return pulumi.get(self, "run_parallel")

    @property
    @pulumi.getter(name="runtimeId")
    def runtime_id(self) -> pulumi.Output[Optional[str]]:
        """
        The ID of the runtime to use for this check.
        """
        return pulumi.get(self, "runtime_id")

    @property
    @pulumi.getter(name="shouldFail")
    def should_fail(self) -> pulumi.Output[Optional[bool]]:
        """
        Allows to invert the behaviour of when a check is considered to fail.
        """
        return pulumi.get(self, "should_fail")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        A list of tags for organizing and filtering checks.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useGlobalAlertSettings")
    def use_global_alert_settings(self) -> pulumi.Output[Optional[bool]]:
        """
        When true, the account level alert settings will be used, not the alert setting defined on this check.
        """
        return pulumi.get(self, "use_global_alert_settings")

