# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'CheckAlertChannelSubscription',
    'CheckAlertSettings',
    'CheckAlertSettingsReminder',
    'CheckAlertSettingsRunBasedEscalation',
    'CheckAlertSettingsSslCertificate',
    'CheckAlertSettingsTimeBasedEscalation',
    'CheckRequest',
    'CheckRequestAssertion',
    'CheckRequestBasicAuth',
]

@pulumi.output_type
class CheckAlertChannelSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertChannelSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertChannelSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertChannelSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activated: bool,
                 channel_id: int):
        """
        :param bool activated: Determines if the check is running or not. Possible values `true`, and `false`.
        """
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @property
    @pulumi.getter
    def activated(self) -> bool:
        """
        Determines if the check is running or not. Possible values `true`, and `false`.
        """
        return pulumi.get(self, "activated")

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> int:
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class CheckAlertSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationType":
            suggest = "escalation_type"
        elif key == "runBasedEscalations":
            suggest = "run_based_escalations"
        elif key == "sslCertificates":
            suggest = "ssl_certificates"
        elif key == "timeBasedEscalations":
            suggest = "time_based_escalations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_type: Optional[str] = None,
                 reminders: Optional[Sequence['outputs.CheckAlertSettingsReminder']] = None,
                 run_based_escalations: Optional[Sequence['outputs.CheckAlertSettingsRunBasedEscalation']] = None,
                 ssl_certificates: Optional[Sequence['outputs.CheckAlertSettingsSslCertificate']] = None,
                 time_based_escalations: Optional[Sequence['outputs.CheckAlertSettingsTimeBasedEscalation']] = None):
        """
        :param str escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        :param Sequence['CheckAlertSettingsReminderArgs'] reminders: . Possible arguments:
        :param Sequence['CheckAlertSettingsRunBasedEscalationArgs'] run_based_escalations: . Possible arguments:
        :param Sequence['CheckAlertSettingsSslCertificateArgs'] ssl_certificates: At what interval the reminders should be send.  Possible arguments:
        :param Sequence['CheckAlertSettingsTimeBasedEscalationArgs'] time_based_escalations: . Possible arguments:
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if ssl_certificates is not None:
            pulumi.set(__self__, "ssl_certificates", ssl_certificates)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[str]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @property
    @pulumi.getter
    def reminders(self) -> Optional[Sequence['outputs.CheckAlertSettingsReminder']]:
        """
        . Possible arguments:
        """
        return pulumi.get(self, "reminders")

    @property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[Sequence['outputs.CheckAlertSettingsRunBasedEscalation']]:
        """
        . Possible arguments:
        """
        return pulumi.get(self, "run_based_escalations")

    @property
    @pulumi.getter(name="sslCertificates")
    def ssl_certificates(self) -> Optional[Sequence['outputs.CheckAlertSettingsSslCertificate']]:
        """
        At what interval the reminders should be send.  Possible arguments:
        """
        return pulumi.get(self, "ssl_certificates")

    @property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[Sequence['outputs.CheckAlertSettingsTimeBasedEscalation']]:
        """
        . Possible arguments:
        """
        return pulumi.get(self, "time_based_escalations")


@pulumi.output_type
class CheckAlertSettingsReminder(dict):
    def __init__(__self__, *,
                 amount: Optional[int] = None,
                 interval: Optional[int] = None):
        """
        :param int amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param int interval: . Possible values are `5`, `10`, `15`, and `30`. Defaults to `5`.
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def amount(self) -> Optional[int]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        . Possible values are `5`, `10`, `15`, and `30`. Defaults to `5`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class CheckAlertSettingsRunBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedRunThreshold":
            suggest = "failed_run_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertSettingsRunBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_run_threshold: Optional[int] = None):
        """
        :param int failed_run_threshold: After how many failed consecutive check runs an alert notification should be send. Possible values are between 1 and 5. Defaults to `1`.
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[int]:
        """
        After how many failed consecutive check runs an alert notification should be send. Possible values are between 1 and 5. Defaults to `1`.
        """
        return pulumi.get(self, "failed_run_threshold")


@pulumi.output_type
class CheckAlertSettingsSslCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertThreshold":
            suggest = "alert_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertSettingsSslCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertSettingsSslCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertSettingsSslCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_threshold: Optional[int] = None,
                 enabled: Optional[bool] = None):
        """
        :param int alert_threshold: At what moment in time to start alerting on SSL certificates. Possible values `3`, `7`, `14`, `30`. Defaults to `3`.
        :param bool enabled: Determines if alert notifications should be send for expiring SSL certificates. Possible values `true`, and `false`. Defaults to `true`.
        """
        if alert_threshold is not None:
            pulumi.set(__self__, "alert_threshold", alert_threshold)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="alertThreshold")
    def alert_threshold(self) -> Optional[int]:
        """
        At what moment in time to start alerting on SSL certificates. Possible values `3`, `7`, `14`, `30`. Defaults to `3`.
        """
        return pulumi.get(self, "alert_threshold")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Determines if alert notifications should be send for expiring SSL certificates. Possible values `true`, and `false`. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CheckAlertSettingsTimeBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesFailingThreshold":
            suggest = "minutes_failing_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertSettingsTimeBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[int] = None):
        """
        :param int minutes_failing_threshold: After how many minutes after a check starts failing an alert should be send. Possible values are `5`, `10`, `15`, and `30`. Defaults to `5`.
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[int]:
        """
        After how many minutes after a check starts failing an alert should be send. Possible values are `5`, `10`, `15`, and `30`. Defaults to `5`.
        """
        return pulumi.get(self, "minutes_failing_threshold")


@pulumi.output_type
class CheckRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "bodyType":
            suggest = "body_type"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "queryParameters":
            suggest = "query_parameters"
        elif key == "skipSsl":
            suggest = "skip_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 assertions: Optional[Sequence['outputs.CheckRequestAssertion']] = None,
                 basic_auth: Optional['outputs.CheckRequestBasicAuth'] = None,
                 body: Optional[str] = None,
                 body_type: Optional[str] = None,
                 follow_redirects: Optional[bool] = None,
                 headers: Optional[Mapping[str, Any]] = None,
                 method: Optional[str] = None,
                 query_parameters: Optional[Mapping[str, Any]] = None,
                 skip_ssl: Optional[bool] = None):
        """
        :param str url: .
        :param Sequence['CheckRequestAssertionArgs'] assertions: A request can have multiple assetions. Assertion has the following arguments:
        :param 'CheckRequestBasicAuthArgs' basic_auth: A request might have one basic_auth config. basic_auth has two arguments:
        :param str body_type: Possible values `NONE`, `JSON`, `FORM`, `RAW`, and `GRAPHQL`.
        :param bool follow_redirects: .
        :param Mapping[str, Any] headers: .
        :param str method: The HTTP method to use for this API check. Possible values are `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`. Defaults to `GET`.
        :param Mapping[str, Any] query_parameters: .
        :param bool skip_ssl: .
        """
        pulumi.set(__self__, "url", url)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if body_type is not None:
            pulumi.set(__self__, "body_type", body_type)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if skip_ssl is not None:
            pulumi.set(__self__, "skip_ssl", skip_ssl)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        .
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.CheckRequestAssertion']]:
        """
        A request can have multiple assetions. Assertion has the following arguments:
        """
        return pulumi.get(self, "assertions")

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.CheckRequestBasicAuth']:
        """
        A request might have one basic_auth config. basic_auth has two arguments:
        """
        return pulumi.get(self, "basic_auth")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="bodyType")
    def body_type(self) -> Optional[str]:
        """
        Possible values `NONE`, `JSON`, `FORM`, `RAW`, and `GRAPHQL`.
        """
        return pulumi.get(self, "body_type")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        .
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, Any]]:
        """
        .
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method to use for this API check. Possible values are `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`. Defaults to `GET`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Mapping[str, Any]]:
        """
        .
        """
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter(name="skipSsl")
    def skip_ssl(self) -> Optional[bool]:
        """
        .
        """
        return pulumi.get(self, "skip_ssl")


@pulumi.output_type
class CheckRequestAssertion(dict):
    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 property: Optional[str] = None,
                 target: Optional[str] = None):
        """
        :param str comparison: Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        :param str source: Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        :param str property: .
        :param str target: .
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        """
        Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        .
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        .
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class CheckRequestBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


