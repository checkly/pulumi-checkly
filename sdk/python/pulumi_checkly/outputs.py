# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AlertChannelCall',
    'AlertChannelEmail',
    'AlertChannelOpsgenie',
    'AlertChannelPagerduty',
    'AlertChannelSlack',
    'AlertChannelSms',
    'AlertChannelWebhook',
    'CheckAlertChannelSubscription',
    'CheckAlertSettings',
    'CheckAlertSettingsParallelRunFailureThreshold',
    'CheckAlertSettingsReminder',
    'CheckAlertSettingsRunBasedEscalation',
    'CheckAlertSettingsSslCertificate',
    'CheckAlertSettingsTimeBasedEscalation',
    'CheckEnvironmentVariable',
    'CheckGroupAlertChannelSubscription',
    'CheckGroupAlertSettings',
    'CheckGroupAlertSettingsParallelRunFailureThreshold',
    'CheckGroupAlertSettingsReminder',
    'CheckGroupAlertSettingsRunBasedEscalation',
    'CheckGroupAlertSettingsSslCertificate',
    'CheckGroupAlertSettingsTimeBasedEscalation',
    'CheckGroupApiCheckDefaults',
    'CheckGroupApiCheckDefaultsAssertion',
    'CheckGroupApiCheckDefaultsBasicAuth',
    'CheckGroupEnvironmentVariable',
    'CheckGroupRetryStrategy',
    'CheckGroupRetryStrategyOnlyOn',
    'CheckRequest',
    'CheckRequestAssertion',
    'CheckRequestBasicAuth',
    'CheckRetryStrategy',
    'CheckRetryStrategyOnlyOn',
    'CheckTriggerIncident',
    'HeartbeatCheckAlertChannelSubscription',
    'HeartbeatCheckAlertSettings',
    'HeartbeatCheckAlertSettingsParallelRunFailureThreshold',
    'HeartbeatCheckAlertSettingsReminder',
    'HeartbeatCheckAlertSettingsRunBasedEscalation',
    'HeartbeatCheckAlertSettingsSslCertificate',
    'HeartbeatCheckAlertSettingsTimeBasedEscalation',
    'HeartbeatCheckHeartbeat',
    'HeartbeatCheckTriggerIncident',
    'HeartbeatMonitorAlertChannelSubscription',
    'HeartbeatMonitorAlertSettings',
    'HeartbeatMonitorAlertSettingsParallelRunFailureThreshold',
    'HeartbeatMonitorAlertSettingsReminder',
    'HeartbeatMonitorAlertSettingsRunBasedEscalation',
    'HeartbeatMonitorAlertSettingsSslCertificate',
    'HeartbeatMonitorAlertSettingsTimeBasedEscalation',
    'HeartbeatMonitorHeartbeat',
    'HeartbeatMonitorTriggerIncident',
    'StatusPageCard',
    'StatusPageCardServiceAttachment',
    'TcpCheckAlertChannelSubscription',
    'TcpCheckAlertSettings',
    'TcpCheckAlertSettingsParallelRunFailureThreshold',
    'TcpCheckAlertSettingsReminder',
    'TcpCheckAlertSettingsRunBasedEscalation',
    'TcpCheckAlertSettingsTimeBasedEscalation',
    'TcpCheckRequest',
    'TcpCheckRequestAssertion',
    'TcpCheckRetryStrategy',
    'TcpCheckRetryStrategyOnlyOn',
    'TcpCheckTriggerIncident',
    'TcpMonitorAlertChannelSubscription',
    'TcpMonitorAlertSettings',
    'TcpMonitorAlertSettingsParallelRunFailureThreshold',
    'TcpMonitorAlertSettingsReminder',
    'TcpMonitorAlertSettingsRunBasedEscalation',
    'TcpMonitorAlertSettingsTimeBasedEscalation',
    'TcpMonitorRequest',
    'TcpMonitorRequestAssertion',
    'TcpMonitorRetryStrategy',
    'TcpMonitorRetryStrategyOnlyOn',
    'TcpMonitorTriggerIncident',
    'UrlMonitorAlertChannelSubscription',
    'UrlMonitorAlertSettings',
    'UrlMonitorAlertSettingsParallelRunFailureThreshold',
    'UrlMonitorAlertSettingsReminder',
    'UrlMonitorAlertSettingsRunBasedEscalation',
    'UrlMonitorAlertSettingsTimeBasedEscalation',
    'UrlMonitorRequest',
    'UrlMonitorRequestAssertion',
    'UrlMonitorRetryStrategy',
    'UrlMonitorRetryStrategyOnlyOn',
    'UrlMonitorTriggerIncident',
]

@pulumi.output_type
class AlertChannelCall(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 number: _builtins.str):
        """
        :param _builtins.str name: The name of this alert channel
        :param _builtins.str number: The mobile number to receive the alerts
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of this alert channel
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.str:
        """
        The mobile number to receive the alerts
        """
        return pulumi.get(self, "number")


@pulumi.output_type
class AlertChannelEmail(dict):
    def __init__(__self__, *,
                 address: _builtins.str):
        """
        :param _builtins.str address: The email address of this email alert channel.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The email address of this email alert channel.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class AlertChannelOpsgenie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertChannelOpsgenie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertChannelOpsgenie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertChannelOpsgenie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 name: _builtins.str,
                 priority: _builtins.str,
                 region: _builtins.str):
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.str:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class AlertChannelPagerduty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceKey":
            suggest = "service_key"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertChannelPagerduty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertChannelPagerduty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertChannelPagerduty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_key: _builtins.str,
                 account: Optional[_builtins.str] = None,
                 service_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "service_key", service_key)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> _builtins.str:
        return pulumi.get(self, "service_key")

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "account")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AlertChannelSlack(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The name of the alert's Slack channel
        :param _builtins.str url: The Slack webhook URL
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The name of the alert's Slack channel
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AlertChannelSms(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 number: _builtins.str):
        """
        :param _builtins.str name: The name of this alert channel
        :param _builtins.str number: The mobile number to receive the alerts
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of this alert channel
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.str:
        """
        The mobile number to receive the alerts
        """
        return pulumi.get(self, "number")


@pulumi.output_type
class AlertChannelWebhook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParameters":
            suggest = "query_parameters"
        elif key == "webhookSecret":
            suggest = "webhook_secret"
        elif key == "webhookType":
            suggest = "webhook_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertChannelWebhook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertChannelWebhook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertChannelWebhook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 url: _builtins.str,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 query_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 template: Optional[_builtins.str] = None,
                 webhook_secret: Optional[_builtins.str] = None,
                 webhook_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str method: (Default `POST`)
        :param _builtins.str webhook_type: Type of the webhook. Possible values are 'WEBHOOK*DISCORD', 'WEBHOOK*FIREHYDRANT', 'WEBHOOK*GITLAB*ALERT', 'WEBHOOK*SPIKESH', 'WEBHOOK*SPLUNK', 'WEBHOOK*MSTEAMS' and 'WEBHOOK*TELEGRAM'.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if webhook_secret is not None:
            pulumi.set(__self__, "webhook_secret", webhook_secret)
        if webhook_type is not None:
            pulumi.set(__self__, "webhook_type", webhook_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        (Default `POST`)
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "query_parameters")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "webhook_secret")

    @_builtins.property
    @pulumi.getter(name="webhookType")
    def webhook_type(self) -> Optional[_builtins.str]:
        """
        Type of the webhook. Possible values are 'WEBHOOK*DISCORD', 'WEBHOOK*FIREHYDRANT', 'WEBHOOK*GITLAB*ALERT', 'WEBHOOK*SPIKESH', 'WEBHOOK*SPLUNK', 'WEBHOOK*MSTEAMS' and 'WEBHOOK*TELEGRAM'.
        """
        return pulumi.get(self, "webhook_type")


@pulumi.output_type
class CheckAlertChannelSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertChannelSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertChannelSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertChannelSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activated: _builtins.bool,
                 channel_id: _builtins.int):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @_builtins.property
    @pulumi.getter
    def activated(self) -> _builtins.bool:
        return pulumi.get(self, "activated")

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> _builtins.int:
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class CheckAlertSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationType":
            suggest = "escalation_type"
        elif key == "parallelRunFailureThresholds":
            suggest = "parallel_run_failure_thresholds"
        elif key == "runBasedEscalations":
            suggest = "run_based_escalations"
        elif key == "sslCertificates":
            suggest = "ssl_certificates"
        elif key == "timeBasedEscalations":
            suggest = "time_based_escalations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_type: Optional[_builtins.str] = None,
                 parallel_run_failure_thresholds: Optional[Sequence['outputs.CheckAlertSettingsParallelRunFailureThreshold']] = None,
                 reminders: Optional[Sequence['outputs.CheckAlertSettingsReminder']] = None,
                 run_based_escalations: Optional[Sequence['outputs.CheckAlertSettingsRunBasedEscalation']] = None,
                 ssl_certificates: Optional[Sequence['outputs.CheckAlertSettingsSslCertificate']] = None,
                 time_based_escalations: Optional[Sequence['outputs.CheckAlertSettingsTimeBasedEscalation']] = None):
        """
        :param _builtins.str escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if ssl_certificates is not None:
            pulumi.set(__self__, "ssl_certificates", ssl_certificates)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @_builtins.property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[_builtins.str]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @_builtins.property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[Sequence['outputs.CheckAlertSettingsParallelRunFailureThreshold']]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @_builtins.property
    @pulumi.getter
    def reminders(self) -> Optional[Sequence['outputs.CheckAlertSettingsReminder']]:
        return pulumi.get(self, "reminders")

    @_builtins.property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[Sequence['outputs.CheckAlertSettingsRunBasedEscalation']]:
        return pulumi.get(self, "run_based_escalations")

    @_builtins.property
    @pulumi.getter(name="sslCertificates")
    @_utilities.deprecated("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
    def ssl_certificates(self) -> Optional[Sequence['outputs.CheckAlertSettingsSslCertificate']]:
        return pulumi.get(self, "ssl_certificates")

    @_builtins.property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[Sequence['outputs.CheckAlertSettingsTimeBasedEscalation']]:
        return pulumi.get(self, "time_based_escalations")


@pulumi.output_type
class CheckAlertSettingsParallelRunFailureThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param _builtins.int percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class CheckAlertSettingsReminder(dict):
    def __init__(__self__, *,
                 amount: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param _builtins.int interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.int]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class CheckAlertSettingsRunBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedRunThreshold":
            suggest = "failed_run_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertSettingsRunBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_run_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @_builtins.property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[_builtins.int]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")


@pulumi.output_type
class CheckAlertSettingsSslCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertThreshold":
            suggest = "alert_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertSettingsSslCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertSettingsSslCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertSettingsSslCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_threshold: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int alert_threshold: How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        :param _builtins.bool enabled: Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        if alert_threshold is not None:
            pulumi.set(__self__, "alert_threshold", alert_threshold)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="alertThreshold")
    def alert_threshold(self) -> Optional[_builtins.int]:
        """
        How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        return pulumi.get(self, "alert_threshold")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CheckAlertSettingsTimeBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesFailingThreshold":
            suggest = "minutes_failing_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckAlertSettingsTimeBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @_builtins.property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[_builtins.int]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")


@pulumi.output_type
class CheckEnvironmentVariable(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 locked: Optional[_builtins.bool] = None,
                 secret: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def locked(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "locked")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "secret")


@pulumi.output_type
class CheckGroupAlertChannelSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckGroupAlertChannelSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckGroupAlertChannelSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckGroupAlertChannelSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activated: _builtins.bool,
                 channel_id: _builtins.int):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @_builtins.property
    @pulumi.getter
    def activated(self) -> _builtins.bool:
        return pulumi.get(self, "activated")

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> _builtins.int:
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class CheckGroupAlertSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationType":
            suggest = "escalation_type"
        elif key == "parallelRunFailureThresholds":
            suggest = "parallel_run_failure_thresholds"
        elif key == "runBasedEscalations":
            suggest = "run_based_escalations"
        elif key == "sslCertificates":
            suggest = "ssl_certificates"
        elif key == "timeBasedEscalations":
            suggest = "time_based_escalations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckGroupAlertSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckGroupAlertSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckGroupAlertSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_type: Optional[_builtins.str] = None,
                 parallel_run_failure_thresholds: Optional[Sequence['outputs.CheckGroupAlertSettingsParallelRunFailureThreshold']] = None,
                 reminders: Optional[Sequence['outputs.CheckGroupAlertSettingsReminder']] = None,
                 run_based_escalations: Optional[Sequence['outputs.CheckGroupAlertSettingsRunBasedEscalation']] = None,
                 ssl_certificates: Optional[Sequence['outputs.CheckGroupAlertSettingsSslCertificate']] = None,
                 time_based_escalations: Optional[Sequence['outputs.CheckGroupAlertSettingsTimeBasedEscalation']] = None):
        """
        :param _builtins.str escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if ssl_certificates is not None:
            pulumi.set(__self__, "ssl_certificates", ssl_certificates)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @_builtins.property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[_builtins.str]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @_builtins.property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[Sequence['outputs.CheckGroupAlertSettingsParallelRunFailureThreshold']]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @_builtins.property
    @pulumi.getter
    def reminders(self) -> Optional[Sequence['outputs.CheckGroupAlertSettingsReminder']]:
        return pulumi.get(self, "reminders")

    @_builtins.property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[Sequence['outputs.CheckGroupAlertSettingsRunBasedEscalation']]:
        return pulumi.get(self, "run_based_escalations")

    @_builtins.property
    @pulumi.getter(name="sslCertificates")
    @_utilities.deprecated("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
    def ssl_certificates(self) -> Optional[Sequence['outputs.CheckGroupAlertSettingsSslCertificate']]:
        return pulumi.get(self, "ssl_certificates")

    @_builtins.property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[Sequence['outputs.CheckGroupAlertSettingsTimeBasedEscalation']]:
        return pulumi.get(self, "time_based_escalations")


@pulumi.output_type
class CheckGroupAlertSettingsParallelRunFailureThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param _builtins.int percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class CheckGroupAlertSettingsReminder(dict):
    def __init__(__self__, *,
                 amount: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param _builtins.int interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.int]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class CheckGroupAlertSettingsRunBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedRunThreshold":
            suggest = "failed_run_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckGroupAlertSettingsRunBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckGroupAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckGroupAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_run_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @_builtins.property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[_builtins.int]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")


@pulumi.output_type
class CheckGroupAlertSettingsSslCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertThreshold":
            suggest = "alert_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckGroupAlertSettingsSslCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckGroupAlertSettingsSslCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckGroupAlertSettingsSslCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_threshold: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int alert_threshold: At what moment in time to start alerting on SSL certificates. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        :param _builtins.bool enabled: Determines if alert notifications should be sent for expiring SSL certificates.
        """
        if alert_threshold is not None:
            pulumi.set(__self__, "alert_threshold", alert_threshold)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="alertThreshold")
    def alert_threshold(self) -> Optional[_builtins.int]:
        """
        At what moment in time to start alerting on SSL certificates. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        return pulumi.get(self, "alert_threshold")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Determines if alert notifications should be sent for expiring SSL certificates.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CheckGroupAlertSettingsTimeBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesFailingThreshold":
            suggest = "minutes_failing_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckGroupAlertSettingsTimeBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckGroupAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckGroupAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @_builtins.property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[_builtins.int]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")


@pulumi.output_type
class CheckGroupApiCheckDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "queryParameters":
            suggest = "query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckGroupApiCheckDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckGroupApiCheckDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckGroupApiCheckDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assertions: Optional[Sequence['outputs.CheckGroupApiCheckDefaultsAssertion']] = None,
                 basic_auth: Optional['outputs.CheckGroupApiCheckDefaultsBasicAuth'] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 query_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The base url for this group which you can reference with the `GROUP_BASE_URL` variable in all group checks.
        """
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if url is None:
            url = ''
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.CheckGroupApiCheckDefaultsAssertion']]:
        return pulumi.get(self, "assertions")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.CheckGroupApiCheckDefaultsBasicAuth']:
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "query_parameters")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The base url for this group which you can reference with the `GROUP_BASE_URL` variable in all group checks.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class CheckGroupApiCheckDefaultsAssertion(dict):
    def __init__(__self__, *,
                 comparison: _builtins.str,
                 source: _builtins.str,
                 target: _builtins.str,
                 property: Optional[_builtins.str] = None):
        """
        :param _builtins.str comparison: The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        :param _builtins.str source: The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def comparison(self) -> _builtins.str:
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        return pulumi.get(self, "comparison")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "property")


@pulumi.output_type
class CheckGroupApiCheckDefaultsBasicAuth(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class CheckGroupEnvironmentVariable(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 locked: Optional[_builtins.bool] = None,
                 secret: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def locked(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "locked")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "secret")


@pulumi.output_type
class CheckGroupRetryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBackoffSeconds":
            suggest = "base_backoff_seconds"
        elif key == "maxDurationSeconds":
            suggest = "max_duration_seconds"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "onlyOn":
            suggest = "only_on"
        elif key == "sameRegion":
            suggest = "same_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckGroupRetryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckGroupRetryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckGroupRetryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 base_backoff_seconds: Optional[_builtins.int] = None,
                 max_duration_seconds: Optional[_builtins.int] = None,
                 max_retries: Optional[_builtins.int] = None,
                 only_on: Optional['outputs.CheckGroupRetryStrategyOnlyOn'] = None,
                 same_region: Optional[_builtins.bool] = None):
        """
        :param _builtins.str type: Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        :param _builtins.int base_backoff_seconds: The number of seconds to wait before the first retry attempt. (Default `60`).
        :param _builtins.int max_duration_seconds: The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        :param _builtins.int max_retries: The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        :param 'CheckGroupRetryStrategyOnlyOnArgs' only_on: Apply the retry strategy only if the defined conditions match.
        :param _builtins.bool same_region: Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        pulumi.set(__self__, "type", type)
        if base_backoff_seconds is not None:
            pulumi.set(__self__, "base_backoff_seconds", base_backoff_seconds)
        if max_duration_seconds is not None:
            pulumi.set(__self__, "max_duration_seconds", max_duration_seconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if only_on is not None:
            pulumi.set(__self__, "only_on", only_on)
        if same_region is not None:
            pulumi.set(__self__, "same_region", same_region)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="baseBackoffSeconds")
    def base_backoff_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait before the first retry attempt. (Default `60`).
        """
        return pulumi.get(self, "base_backoff_seconds")

    @_builtins.property
    @pulumi.getter(name="maxDurationSeconds")
    def max_duration_seconds(self) -> Optional[_builtins.int]:
        """
        The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        """
        return pulumi.get(self, "max_duration_seconds")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="onlyOn")
    def only_on(self) -> Optional['outputs.CheckGroupRetryStrategyOnlyOn']:
        """
        Apply the retry strategy only if the defined conditions match.
        """
        return pulumi.get(self, "only_on")

    @_builtins.property
    @pulumi.getter(name="sameRegion")
    def same_region(self) -> Optional[_builtins.bool]:
        """
        Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        return pulumi.get(self, "same_region")


@pulumi.output_type
class CheckGroupRetryStrategyOnlyOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkError":
            suggest = "network_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckGroupRetryStrategyOnlyOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckGroupRetryStrategyOnlyOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckGroupRetryStrategyOnlyOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_error: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool network_error: When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        if network_error is not None:
            pulumi.set(__self__, "network_error", network_error)

    @_builtins.property
    @pulumi.getter(name="networkError")
    def network_error(self) -> Optional[_builtins.bool]:
        """
        When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        return pulumi.get(self, "network_error")


@pulumi.output_type
class CheckRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "bodyType":
            suggest = "body_type"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "ipFamily":
            suggest = "ip_family"
        elif key == "queryParameters":
            suggest = "query_parameters"
        elif key == "skipSsl":
            suggest = "skip_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 assertions: Optional[Sequence['outputs.CheckRequestAssertion']] = None,
                 basic_auth: Optional['outputs.CheckRequestBasicAuth'] = None,
                 body: Optional[_builtins.str] = None,
                 body_type: Optional[_builtins.str] = None,
                 follow_redirects: Optional[_builtins.bool] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 ip_family: Optional[_builtins.str] = None,
                 method: Optional[_builtins.str] = None,
                 query_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 skip_ssl: Optional[_builtins.bool] = None):
        """
        :param Sequence['CheckRequestAssertionArgs'] assertions: A request can have multiple assertions.
        :param 'CheckRequestBasicAuthArgs' basic_auth: Set up HTTP basic authentication (username & password).
        :param _builtins.str body: The body of the request.
        :param _builtins.str body_type: The `Content-Type` header of the request. Possible values `NONE`, `JSON`, `FORM`, `RAW`, and `GRAPHQL`.
        :param _builtins.str ip_family: IP Family to be used when executing the api check. The value can be either IPv4 or IPv6.
        :param _builtins.str method: The HTTP method to use for this API check. Possible values are `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`. (Default `GET`).
        """
        pulumi.set(__self__, "url", url)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if body_type is not None:
            pulumi.set(__self__, "body_type", body_type)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_family is not None:
            pulumi.set(__self__, "ip_family", ip_family)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if skip_ssl is not None:
            pulumi.set(__self__, "skip_ssl", skip_ssl)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.CheckRequestAssertion']]:
        """
        A request can have multiple assertions.
        """
        return pulumi.get(self, "assertions")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.CheckRequestBasicAuth']:
        """
        Set up HTTP basic authentication (username & password).
        """
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[_builtins.str]:
        """
        The body of the request.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter(name="bodyType")
    def body_type(self) -> Optional[_builtins.str]:
        """
        The `Content-Type` header of the request. Possible values `NONE`, `JSON`, `FORM`, `RAW`, and `GRAPHQL`.
        """
        return pulumi.get(self, "body_type")

    @_builtins.property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "follow_redirects")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ipFamily")
    def ip_family(self) -> Optional[_builtins.str]:
        """
        IP Family to be used when executing the api check. The value can be either IPv4 or IPv6.
        """
        return pulumi.get(self, "ip_family")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        The HTTP method to use for this API check. Possible values are `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`. (Default `GET`).
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "query_parameters")

    @_builtins.property
    @pulumi.getter(name="skipSsl")
    def skip_ssl(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "skip_ssl")


@pulumi.output_type
class CheckRequestAssertion(dict):
    def __init__(__self__, *,
                 comparison: _builtins.str,
                 source: _builtins.str,
                 property: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None):
        """
        :param _builtins.str comparison: The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        :param _builtins.str source: The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def comparison(self) -> _builtins.str:
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        return pulumi.get(self, "comparison")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The source of the asserted value. Possible values `STATUS_CODE`, `JSON_BODY`, `HEADERS`, `TEXT_BODY`, and `RESPONSE_TIME`.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "property")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target")


@pulumi.output_type
class CheckRequestBasicAuth(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class CheckRetryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBackoffSeconds":
            suggest = "base_backoff_seconds"
        elif key == "maxDurationSeconds":
            suggest = "max_duration_seconds"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "onlyOn":
            suggest = "only_on"
        elif key == "sameRegion":
            suggest = "same_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckRetryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckRetryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckRetryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 base_backoff_seconds: Optional[_builtins.int] = None,
                 max_duration_seconds: Optional[_builtins.int] = None,
                 max_retries: Optional[_builtins.int] = None,
                 only_on: Optional['outputs.CheckRetryStrategyOnlyOn'] = None,
                 same_region: Optional[_builtins.bool] = None):
        """
        :param _builtins.str type: Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        :param _builtins.int base_backoff_seconds: The number of seconds to wait before the first retry attempt. (Default `60`).
        :param _builtins.int max_duration_seconds: The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        :param _builtins.int max_retries: The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        :param 'CheckRetryStrategyOnlyOnArgs' only_on: Apply the retry strategy only if the defined conditions match.
        :param _builtins.bool same_region: Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        pulumi.set(__self__, "type", type)
        if base_backoff_seconds is not None:
            pulumi.set(__self__, "base_backoff_seconds", base_backoff_seconds)
        if max_duration_seconds is not None:
            pulumi.set(__self__, "max_duration_seconds", max_duration_seconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if only_on is not None:
            pulumi.set(__self__, "only_on", only_on)
        if same_region is not None:
            pulumi.set(__self__, "same_region", same_region)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="baseBackoffSeconds")
    def base_backoff_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait before the first retry attempt. (Default `60`).
        """
        return pulumi.get(self, "base_backoff_seconds")

    @_builtins.property
    @pulumi.getter(name="maxDurationSeconds")
    def max_duration_seconds(self) -> Optional[_builtins.int]:
        """
        The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        """
        return pulumi.get(self, "max_duration_seconds")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="onlyOn")
    def only_on(self) -> Optional['outputs.CheckRetryStrategyOnlyOn']:
        """
        Apply the retry strategy only if the defined conditions match.
        """
        return pulumi.get(self, "only_on")

    @_builtins.property
    @pulumi.getter(name="sameRegion")
    def same_region(self) -> Optional[_builtins.bool]:
        """
        Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        return pulumi.get(self, "same_region")


@pulumi.output_type
class CheckRetryStrategyOnlyOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkError":
            suggest = "network_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckRetryStrategyOnlyOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckRetryStrategyOnlyOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckRetryStrategyOnlyOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_error: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool network_error: When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        if network_error is not None:
            pulumi.set(__self__, "network_error", network_error)

    @_builtins.property
    @pulumi.getter(name="networkError")
    def network_error(self) -> Optional[_builtins.bool]:
        """
        When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        return pulumi.get(self, "network_error")


@pulumi.output_type
class CheckTriggerIncident(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifySubscribers":
            suggest = "notify_subscribers"
        elif key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckTriggerIncident. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckTriggerIncident.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckTriggerIncident.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 notify_subscribers: _builtins.bool,
                 service_id: _builtins.str,
                 severity: _builtins.str):
        """
        :param _builtins.str description: A detailed description of the incident.
        :param _builtins.str name: The name of the incident.
        :param _builtins.bool notify_subscribers: Whether to notify subscribers when the incident is triggered.
        :param _builtins.str service_id: The status page service that this incident will be associated with.
        :param _builtins.str severity: The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_subscribers", notify_subscribers)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A detailed description of the incident.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the incident.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifySubscribers")
    def notify_subscribers(self) -> _builtins.bool:
        """
        Whether to notify subscribers when the incident is triggered.
        """
        return pulumi.get(self, "notify_subscribers")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The status page service that this incident will be associated with.
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class HeartbeatCheckAlertChannelSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatCheckAlertChannelSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatCheckAlertChannelSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatCheckAlertChannelSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activated: _builtins.bool,
                 channel_id: _builtins.int):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @_builtins.property
    @pulumi.getter
    def activated(self) -> _builtins.bool:
        return pulumi.get(self, "activated")

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> _builtins.int:
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class HeartbeatCheckAlertSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationType":
            suggest = "escalation_type"
        elif key == "parallelRunFailureThresholds":
            suggest = "parallel_run_failure_thresholds"
        elif key == "runBasedEscalations":
            suggest = "run_based_escalations"
        elif key == "sslCertificates":
            suggest = "ssl_certificates"
        elif key == "timeBasedEscalations":
            suggest = "time_based_escalations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatCheckAlertSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatCheckAlertSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatCheckAlertSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_type: Optional[_builtins.str] = None,
                 parallel_run_failure_thresholds: Optional[Sequence['outputs.HeartbeatCheckAlertSettingsParallelRunFailureThreshold']] = None,
                 reminders: Optional[Sequence['outputs.HeartbeatCheckAlertSettingsReminder']] = None,
                 run_based_escalations: Optional[Sequence['outputs.HeartbeatCheckAlertSettingsRunBasedEscalation']] = None,
                 ssl_certificates: Optional[Sequence['outputs.HeartbeatCheckAlertSettingsSslCertificate']] = None,
                 time_based_escalations: Optional[Sequence['outputs.HeartbeatCheckAlertSettingsTimeBasedEscalation']] = None):
        """
        :param _builtins.str escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if ssl_certificates is not None:
            pulumi.set(__self__, "ssl_certificates", ssl_certificates)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @_builtins.property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[_builtins.str]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @_builtins.property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[Sequence['outputs.HeartbeatCheckAlertSettingsParallelRunFailureThreshold']]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @_builtins.property
    @pulumi.getter
    def reminders(self) -> Optional[Sequence['outputs.HeartbeatCheckAlertSettingsReminder']]:
        return pulumi.get(self, "reminders")

    @_builtins.property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[Sequence['outputs.HeartbeatCheckAlertSettingsRunBasedEscalation']]:
        return pulumi.get(self, "run_based_escalations")

    @_builtins.property
    @pulumi.getter(name="sslCertificates")
    @_utilities.deprecated("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
    def ssl_certificates(self) -> Optional[Sequence['outputs.HeartbeatCheckAlertSettingsSslCertificate']]:
        return pulumi.get(self, "ssl_certificates")

    @_builtins.property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[Sequence['outputs.HeartbeatCheckAlertSettingsTimeBasedEscalation']]:
        return pulumi.get(self, "time_based_escalations")


@pulumi.output_type
class HeartbeatCheckAlertSettingsParallelRunFailureThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param _builtins.int percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class HeartbeatCheckAlertSettingsReminder(dict):
    def __init__(__self__, *,
                 amount: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param _builtins.int interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.int]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class HeartbeatCheckAlertSettingsRunBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedRunThreshold":
            suggest = "failed_run_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatCheckAlertSettingsRunBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatCheckAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatCheckAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_run_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @_builtins.property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[_builtins.int]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")


@pulumi.output_type
class HeartbeatCheckAlertSettingsSslCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertThreshold":
            suggest = "alert_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatCheckAlertSettingsSslCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatCheckAlertSettingsSslCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatCheckAlertSettingsSslCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_threshold: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int alert_threshold: How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        :param _builtins.bool enabled: Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        if alert_threshold is not None:
            pulumi.set(__self__, "alert_threshold", alert_threshold)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="alertThreshold")
    def alert_threshold(self) -> Optional[_builtins.int]:
        """
        How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        return pulumi.get(self, "alert_threshold")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class HeartbeatCheckAlertSettingsTimeBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesFailingThreshold":
            suggest = "minutes_failing_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatCheckAlertSettingsTimeBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatCheckAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatCheckAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @_builtins.property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[_builtins.int]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")


@pulumi.output_type
class HeartbeatCheckHeartbeat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "graceUnit":
            suggest = "grace_unit"
        elif key == "periodUnit":
            suggest = "period_unit"
        elif key == "pingToken":
            suggest = "ping_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatCheckHeartbeat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatCheckHeartbeat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatCheckHeartbeat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace: _builtins.int,
                 grace_unit: _builtins.str,
                 period: _builtins.int,
                 period_unit: _builtins.str,
                 ping_token: Optional[_builtins.str] = None):
        """
        :param _builtins.int grace: How long Checkly should wait before triggering any alerts when a ping does not arrive within the set period.
        :param _builtins.str grace_unit: Possible values `seconds`, `minutes`, `hours` and `days`.
        :param _builtins.int period: How often you expect a ping to the ping URL.
        :param _builtins.str period_unit: Possible values `seconds`, `minutes`, `hours` and `days`.
        :param _builtins.str ping_token: Custom token to generate your ping URL. Checkly will expect a ping to `https://ping.checklyhq.com/[PING_TOKEN]`.
        """
        pulumi.set(__self__, "grace", grace)
        pulumi.set(__self__, "grace_unit", grace_unit)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "period_unit", period_unit)
        if ping_token is not None:
            pulumi.set(__self__, "ping_token", ping_token)

    @_builtins.property
    @pulumi.getter
    def grace(self) -> _builtins.int:
        """
        How long Checkly should wait before triggering any alerts when a ping does not arrive within the set period.
        """
        return pulumi.get(self, "grace")

    @_builtins.property
    @pulumi.getter(name="graceUnit")
    def grace_unit(self) -> _builtins.str:
        """
        Possible values `seconds`, `minutes`, `hours` and `days`.
        """
        return pulumi.get(self, "grace_unit")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        How often you expect a ping to the ping URL.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="periodUnit")
    def period_unit(self) -> _builtins.str:
        """
        Possible values `seconds`, `minutes`, `hours` and `days`.
        """
        return pulumi.get(self, "period_unit")

    @_builtins.property
    @pulumi.getter(name="pingToken")
    def ping_token(self) -> Optional[_builtins.str]:
        """
        Custom token to generate your ping URL. Checkly will expect a ping to `https://ping.checklyhq.com/[PING_TOKEN]`.
        """
        return pulumi.get(self, "ping_token")


@pulumi.output_type
class HeartbeatCheckTriggerIncident(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifySubscribers":
            suggest = "notify_subscribers"
        elif key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatCheckTriggerIncident. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatCheckTriggerIncident.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatCheckTriggerIncident.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 notify_subscribers: _builtins.bool,
                 service_id: _builtins.str,
                 severity: _builtins.str):
        """
        :param _builtins.str description: A detailed description of the incident.
        :param _builtins.str name: The name of the incident.
        :param _builtins.bool notify_subscribers: Whether to notify subscribers when the incident is triggered.
        :param _builtins.str service_id: The status page service that this incident will be associated with.
        :param _builtins.str severity: The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_subscribers", notify_subscribers)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A detailed description of the incident.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the incident.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifySubscribers")
    def notify_subscribers(self) -> _builtins.bool:
        """
        Whether to notify subscribers when the incident is triggered.
        """
        return pulumi.get(self, "notify_subscribers")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The status page service that this incident will be associated with.
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class HeartbeatMonitorAlertChannelSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatMonitorAlertChannelSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatMonitorAlertChannelSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatMonitorAlertChannelSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activated: _builtins.bool,
                 channel_id: _builtins.int):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @_builtins.property
    @pulumi.getter
    def activated(self) -> _builtins.bool:
        return pulumi.get(self, "activated")

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> _builtins.int:
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class HeartbeatMonitorAlertSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationType":
            suggest = "escalation_type"
        elif key == "parallelRunFailureThresholds":
            suggest = "parallel_run_failure_thresholds"
        elif key == "runBasedEscalations":
            suggest = "run_based_escalations"
        elif key == "sslCertificates":
            suggest = "ssl_certificates"
        elif key == "timeBasedEscalations":
            suggest = "time_based_escalations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatMonitorAlertSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatMonitorAlertSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatMonitorAlertSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_type: Optional[_builtins.str] = None,
                 parallel_run_failure_thresholds: Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsParallelRunFailureThreshold']] = None,
                 reminders: Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsReminder']] = None,
                 run_based_escalations: Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsRunBasedEscalation']] = None,
                 ssl_certificates: Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsSslCertificate']] = None,
                 time_based_escalations: Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsTimeBasedEscalation']] = None):
        """
        :param _builtins.str escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if ssl_certificates is not None:
            pulumi.set(__self__, "ssl_certificates", ssl_certificates)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @_builtins.property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[_builtins.str]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @_builtins.property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsParallelRunFailureThreshold']]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @_builtins.property
    @pulumi.getter
    def reminders(self) -> Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsReminder']]:
        return pulumi.get(self, "reminders")

    @_builtins.property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsRunBasedEscalation']]:
        return pulumi.get(self, "run_based_escalations")

    @_builtins.property
    @pulumi.getter(name="sslCertificates")
    @_utilities.deprecated("""This property is deprecated and it's ignored by the Checkly Public API. It will be removed in a future version.""")
    def ssl_certificates(self) -> Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsSslCertificate']]:
        return pulumi.get(self, "ssl_certificates")

    @_builtins.property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[Sequence['outputs.HeartbeatMonitorAlertSettingsTimeBasedEscalation']]:
        return pulumi.get(self, "time_based_escalations")


@pulumi.output_type
class HeartbeatMonitorAlertSettingsParallelRunFailureThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param _builtins.int percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class HeartbeatMonitorAlertSettingsReminder(dict):
    def __init__(__self__, *,
                 amount: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param _builtins.int interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.int]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class HeartbeatMonitorAlertSettingsRunBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedRunThreshold":
            suggest = "failed_run_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatMonitorAlertSettingsRunBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatMonitorAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatMonitorAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_run_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @_builtins.property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[_builtins.int]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")


@pulumi.output_type
class HeartbeatMonitorAlertSettingsSslCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertThreshold":
            suggest = "alert_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatMonitorAlertSettingsSslCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatMonitorAlertSettingsSslCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatMonitorAlertSettingsSslCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_threshold: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int alert_threshold: How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        :param _builtins.bool enabled: Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        if alert_threshold is not None:
            pulumi.set(__self__, "alert_threshold", alert_threshold)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="alertThreshold")
    def alert_threshold(self) -> Optional[_builtins.int]:
        """
        How long before SSL certificate expiry to send alerts. Possible values `3`, `7`, `14`, `30`. (Default `3`).
        """
        return pulumi.get(self, "alert_threshold")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Determines if alert notifications should be sent for expiring SSL certificates. Possible values `true`, and `false`. (Default `false`).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class HeartbeatMonitorAlertSettingsTimeBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesFailingThreshold":
            suggest = "minutes_failing_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatMonitorAlertSettingsTimeBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatMonitorAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatMonitorAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @_builtins.property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[_builtins.int]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")


@pulumi.output_type
class HeartbeatMonitorHeartbeat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "graceUnit":
            suggest = "grace_unit"
        elif key == "periodUnit":
            suggest = "period_unit"
        elif key == "pingToken":
            suggest = "ping_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatMonitorHeartbeat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatMonitorHeartbeat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatMonitorHeartbeat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace: _builtins.int,
                 grace_unit: _builtins.str,
                 period: _builtins.int,
                 period_unit: _builtins.str,
                 ping_token: Optional[_builtins.str] = None):
        """
        :param _builtins.int grace: How long Checkly should wait before triggering any alerts when a ping does not arrive within the set period.
        :param _builtins.str grace_unit: Possible values `seconds`, `minutes`, `hours` and `days`.
        :param _builtins.int period: How often you expect a ping to the ping URL.
        :param _builtins.str period_unit: Possible values `seconds`, `minutes`, `hours` and `days`.
        :param _builtins.str ping_token: Custom token to generate your ping URL. Checkly will expect a ping to `https://ping.checklyhq.com/[PING_TOKEN]`.
        """
        pulumi.set(__self__, "grace", grace)
        pulumi.set(__self__, "grace_unit", grace_unit)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "period_unit", period_unit)
        if ping_token is not None:
            pulumi.set(__self__, "ping_token", ping_token)

    @_builtins.property
    @pulumi.getter
    def grace(self) -> _builtins.int:
        """
        How long Checkly should wait before triggering any alerts when a ping does not arrive within the set period.
        """
        return pulumi.get(self, "grace")

    @_builtins.property
    @pulumi.getter(name="graceUnit")
    def grace_unit(self) -> _builtins.str:
        """
        Possible values `seconds`, `minutes`, `hours` and `days`.
        """
        return pulumi.get(self, "grace_unit")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        How often you expect a ping to the ping URL.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="periodUnit")
    def period_unit(self) -> _builtins.str:
        """
        Possible values `seconds`, `minutes`, `hours` and `days`.
        """
        return pulumi.get(self, "period_unit")

    @_builtins.property
    @pulumi.getter(name="pingToken")
    def ping_token(self) -> Optional[_builtins.str]:
        """
        Custom token to generate your ping URL. Checkly will expect a ping to `https://ping.checklyhq.com/[PING_TOKEN]`.
        """
        return pulumi.get(self, "ping_token")


@pulumi.output_type
class HeartbeatMonitorTriggerIncident(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifySubscribers":
            suggest = "notify_subscribers"
        elif key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeartbeatMonitorTriggerIncident. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeartbeatMonitorTriggerIncident.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeartbeatMonitorTriggerIncident.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 notify_subscribers: _builtins.bool,
                 service_id: _builtins.str,
                 severity: _builtins.str):
        """
        :param _builtins.str description: A detailed description of the incident.
        :param _builtins.str name: The name of the incident.
        :param _builtins.bool notify_subscribers: Whether to notify subscribers when the incident is triggered.
        :param _builtins.str service_id: The status page service that this incident will be associated with.
        :param _builtins.str severity: The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_subscribers", notify_subscribers)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A detailed description of the incident.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the incident.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifySubscribers")
    def notify_subscribers(self) -> _builtins.bool:
        """
        Whether to notify subscribers when the incident is triggered.
        """
        return pulumi.get(self, "notify_subscribers")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The status page service that this incident will be associated with.
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class StatusPageCard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAttachments":
            suggest = "service_attachments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusPageCard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusPageCard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusPageCard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 service_attachments: Sequence['outputs.StatusPageCardServiceAttachment']):
        """
        :param _builtins.str name: The name of the card.
        :param Sequence['StatusPageCardServiceAttachmentArgs'] service_attachments: A list of services to attach to the card.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_attachments", service_attachments)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the card.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceAttachments")
    def service_attachments(self) -> Sequence['outputs.StatusPageCardServiceAttachment']:
        """
        A list of services to attach to the card.
        """
        return pulumi.get(self, "service_attachments")


@pulumi.output_type
class StatusPageCardServiceAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusPageCardServiceAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusPageCardServiceAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusPageCardServiceAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_id: _builtins.str):
        """
        :param _builtins.str service_id: The ID of the service.
        """
        pulumi.set(__self__, "service_id", service_id)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The ID of the service.
        """
        return pulumi.get(self, "service_id")


@pulumi.output_type
class TcpCheckAlertChannelSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpCheckAlertChannelSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpCheckAlertChannelSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpCheckAlertChannelSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activated: _builtins.bool,
                 channel_id: _builtins.int):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @_builtins.property
    @pulumi.getter
    def activated(self) -> _builtins.bool:
        return pulumi.get(self, "activated")

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> _builtins.int:
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class TcpCheckAlertSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationType":
            suggest = "escalation_type"
        elif key == "parallelRunFailureThresholds":
            suggest = "parallel_run_failure_thresholds"
        elif key == "runBasedEscalations":
            suggest = "run_based_escalations"
        elif key == "timeBasedEscalations":
            suggest = "time_based_escalations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpCheckAlertSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpCheckAlertSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpCheckAlertSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_type: Optional[_builtins.str] = None,
                 parallel_run_failure_thresholds: Optional[Sequence['outputs.TcpCheckAlertSettingsParallelRunFailureThreshold']] = None,
                 reminders: Optional[Sequence['outputs.TcpCheckAlertSettingsReminder']] = None,
                 run_based_escalations: Optional[Sequence['outputs.TcpCheckAlertSettingsRunBasedEscalation']] = None,
                 time_based_escalations: Optional[Sequence['outputs.TcpCheckAlertSettingsTimeBasedEscalation']] = None):
        """
        :param _builtins.str escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @_builtins.property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[_builtins.str]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @_builtins.property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[Sequence['outputs.TcpCheckAlertSettingsParallelRunFailureThreshold']]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @_builtins.property
    @pulumi.getter
    def reminders(self) -> Optional[Sequence['outputs.TcpCheckAlertSettingsReminder']]:
        return pulumi.get(self, "reminders")

    @_builtins.property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[Sequence['outputs.TcpCheckAlertSettingsRunBasedEscalation']]:
        return pulumi.get(self, "run_based_escalations")

    @_builtins.property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[Sequence['outputs.TcpCheckAlertSettingsTimeBasedEscalation']]:
        return pulumi.get(self, "time_based_escalations")


@pulumi.output_type
class TcpCheckAlertSettingsParallelRunFailureThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param _builtins.int percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class TcpCheckAlertSettingsReminder(dict):
    def __init__(__self__, *,
                 amount: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param _builtins.int interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.int]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class TcpCheckAlertSettingsRunBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedRunThreshold":
            suggest = "failed_run_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpCheckAlertSettingsRunBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpCheckAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpCheckAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_run_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @_builtins.property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[_builtins.int]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")


@pulumi.output_type
class TcpCheckAlertSettingsTimeBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesFailingThreshold":
            suggest = "minutes_failing_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpCheckAlertSettingsTimeBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpCheckAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpCheckAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @_builtins.property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[_builtins.int]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")


@pulumi.output_type
class TcpCheckRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFamily":
            suggest = "ip_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpCheckRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpCheckRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpCheckRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 port: _builtins.int,
                 assertions: Optional[Sequence['outputs.TcpCheckRequestAssertion']] = None,
                 data: Optional[_builtins.str] = None,
                 ip_family: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The hostname or IP to connect to. Do not include a scheme or a port in this value.
        :param _builtins.int port: The port number to connect to.
        :param Sequence['TcpCheckRequestAssertionArgs'] assertions: A request can have multiple assertions.
        :param _builtins.str data: The data to send to the target host.
        :param _builtins.str ip_family: The IP family to use when executing the TCP check. The value can be either `IPv4` or `IPv6`.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if ip_family is not None:
            pulumi.set(__self__, "ip_family", ip_family)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The hostname or IP to connect to. Do not include a scheme or a port in this value.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number to connect to.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.TcpCheckRequestAssertion']]:
        """
        A request can have multiple assertions.
        """
        return pulumi.get(self, "assertions")

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[_builtins.str]:
        """
        The data to send to the target host.
        """
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter(name="ipFamily")
    def ip_family(self) -> Optional[_builtins.str]:
        """
        The IP family to use when executing the TCP check. The value can be either `IPv4` or `IPv6`.
        """
        return pulumi.get(self, "ip_family")


@pulumi.output_type
class TcpCheckRequestAssertion(dict):
    def __init__(__self__, *,
                 comparison: _builtins.str,
                 source: _builtins.str,
                 property: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None):
        """
        :param _builtins.str comparison: The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        :param _builtins.str source: The source of the asserted value. Possible values are `RESPONSE_DATA` and `RESPONSE_TIME`.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def comparison(self) -> _builtins.str:
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        return pulumi.get(self, "comparison")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The source of the asserted value. Possible values are `RESPONSE_DATA` and `RESPONSE_TIME`.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "property")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target")


@pulumi.output_type
class TcpCheckRetryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBackoffSeconds":
            suggest = "base_backoff_seconds"
        elif key == "maxDurationSeconds":
            suggest = "max_duration_seconds"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "onlyOn":
            suggest = "only_on"
        elif key == "sameRegion":
            suggest = "same_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpCheckRetryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpCheckRetryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpCheckRetryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 base_backoff_seconds: Optional[_builtins.int] = None,
                 max_duration_seconds: Optional[_builtins.int] = None,
                 max_retries: Optional[_builtins.int] = None,
                 only_on: Optional['outputs.TcpCheckRetryStrategyOnlyOn'] = None,
                 same_region: Optional[_builtins.bool] = None):
        """
        :param _builtins.str type: Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        :param _builtins.int base_backoff_seconds: The number of seconds to wait before the first retry attempt. (Default `60`).
        :param _builtins.int max_duration_seconds: The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        :param _builtins.int max_retries: The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        :param 'TcpCheckRetryStrategyOnlyOnArgs' only_on: Apply the retry strategy only if the defined conditions match.
        :param _builtins.bool same_region: Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        pulumi.set(__self__, "type", type)
        if base_backoff_seconds is not None:
            pulumi.set(__self__, "base_backoff_seconds", base_backoff_seconds)
        if max_duration_seconds is not None:
            pulumi.set(__self__, "max_duration_seconds", max_duration_seconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if only_on is not None:
            pulumi.set(__self__, "only_on", only_on)
        if same_region is not None:
            pulumi.set(__self__, "same_region", same_region)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="baseBackoffSeconds")
    def base_backoff_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait before the first retry attempt. (Default `60`).
        """
        return pulumi.get(self, "base_backoff_seconds")

    @_builtins.property
    @pulumi.getter(name="maxDurationSeconds")
    def max_duration_seconds(self) -> Optional[_builtins.int]:
        """
        The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        """
        return pulumi.get(self, "max_duration_seconds")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="onlyOn")
    def only_on(self) -> Optional['outputs.TcpCheckRetryStrategyOnlyOn']:
        """
        Apply the retry strategy only if the defined conditions match.
        """
        return pulumi.get(self, "only_on")

    @_builtins.property
    @pulumi.getter(name="sameRegion")
    def same_region(self) -> Optional[_builtins.bool]:
        """
        Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        return pulumi.get(self, "same_region")


@pulumi.output_type
class TcpCheckRetryStrategyOnlyOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkError":
            suggest = "network_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpCheckRetryStrategyOnlyOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpCheckRetryStrategyOnlyOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpCheckRetryStrategyOnlyOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_error: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool network_error: When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        if network_error is not None:
            pulumi.set(__self__, "network_error", network_error)

    @_builtins.property
    @pulumi.getter(name="networkError")
    def network_error(self) -> Optional[_builtins.bool]:
        """
        When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        return pulumi.get(self, "network_error")


@pulumi.output_type
class TcpCheckTriggerIncident(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifySubscribers":
            suggest = "notify_subscribers"
        elif key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpCheckTriggerIncident. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpCheckTriggerIncident.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpCheckTriggerIncident.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 notify_subscribers: _builtins.bool,
                 service_id: _builtins.str,
                 severity: _builtins.str):
        """
        :param _builtins.str description: A detailed description of the incident.
        :param _builtins.str name: The name of the incident.
        :param _builtins.bool notify_subscribers: Whether to notify subscribers when the incident is triggered.
        :param _builtins.str service_id: The status page service that this incident will be associated with.
        :param _builtins.str severity: The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_subscribers", notify_subscribers)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A detailed description of the incident.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the incident.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifySubscribers")
    def notify_subscribers(self) -> _builtins.bool:
        """
        Whether to notify subscribers when the incident is triggered.
        """
        return pulumi.get(self, "notify_subscribers")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The status page service that this incident will be associated with.
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class TcpMonitorAlertChannelSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpMonitorAlertChannelSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpMonitorAlertChannelSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpMonitorAlertChannelSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activated: _builtins.bool,
                 channel_id: _builtins.int):
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @_builtins.property
    @pulumi.getter
    def activated(self) -> _builtins.bool:
        return pulumi.get(self, "activated")

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> _builtins.int:
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class TcpMonitorAlertSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationType":
            suggest = "escalation_type"
        elif key == "parallelRunFailureThresholds":
            suggest = "parallel_run_failure_thresholds"
        elif key == "runBasedEscalations":
            suggest = "run_based_escalations"
        elif key == "timeBasedEscalations":
            suggest = "time_based_escalations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpMonitorAlertSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpMonitorAlertSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpMonitorAlertSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_type: Optional[_builtins.str] = None,
                 parallel_run_failure_thresholds: Optional[Sequence['outputs.TcpMonitorAlertSettingsParallelRunFailureThreshold']] = None,
                 reminders: Optional[Sequence['outputs.TcpMonitorAlertSettingsReminder']] = None,
                 run_based_escalations: Optional[Sequence['outputs.TcpMonitorAlertSettingsRunBasedEscalation']] = None,
                 time_based_escalations: Optional[Sequence['outputs.TcpMonitorAlertSettingsTimeBasedEscalation']] = None):
        """
        :param _builtins.str escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        if escalation_type is not None:
            pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @_builtins.property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> Optional[_builtins.str]:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` or `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @_builtins.property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[Sequence['outputs.TcpMonitorAlertSettingsParallelRunFailureThreshold']]:
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @_builtins.property
    @pulumi.getter
    def reminders(self) -> Optional[Sequence['outputs.TcpMonitorAlertSettingsReminder']]:
        return pulumi.get(self, "reminders")

    @_builtins.property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[Sequence['outputs.TcpMonitorAlertSettingsRunBasedEscalation']]:
        return pulumi.get(self, "run_based_escalations")

    @_builtins.property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[Sequence['outputs.TcpMonitorAlertSettingsTimeBasedEscalation']]:
        return pulumi.get(self, "time_based_escalations")


@pulumi.output_type
class TcpMonitorAlertSettingsParallelRunFailureThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Applicable only for checks scheduled in parallel in multiple locations.
        :param _builtins.int percentage: Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Applicable only for checks scheduled in parallel in multiple locations.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `100`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class TcpMonitorAlertSettingsReminder(dict):
    def __init__(__self__, *,
                 amount: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int amount: How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        :param _builtins.int interval: Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.int]:
        """
        How many reminders to send out after the initial alert notification. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000`
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class TcpMonitorAlertSettingsRunBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedRunThreshold":
            suggest = "failed_run_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpMonitorAlertSettingsRunBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpMonitorAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpMonitorAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_run_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @_builtins.property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[_builtins.int]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between 1 and 5. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")


@pulumi.output_type
class TcpMonitorAlertSettingsTimeBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesFailingThreshold":
            suggest = "minutes_failing_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpMonitorAlertSettingsTimeBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpMonitorAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpMonitorAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int minutes_failing_threshold: After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @_builtins.property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[_builtins.int]:
        """
        After how many minutes after a check starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")


@pulumi.output_type
class TcpMonitorRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFamily":
            suggest = "ip_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpMonitorRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpMonitorRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpMonitorRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 port: _builtins.int,
                 assertions: Optional[Sequence['outputs.TcpMonitorRequestAssertion']] = None,
                 data: Optional[_builtins.str] = None,
                 ip_family: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The hostname or IP to connect to. Do not include a scheme or a port in this value.
        :param _builtins.int port: The port number to connect to.
        :param Sequence['TcpMonitorRequestAssertionArgs'] assertions: A request can have multiple assertions.
        :param _builtins.str data: The data to send to the target host.
        :param _builtins.str ip_family: The IP family to use when executing the TCP check. The value can be either `IPv4` or `IPv6`.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if ip_family is not None:
            pulumi.set(__self__, "ip_family", ip_family)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The hostname or IP to connect to. Do not include a scheme or a port in this value.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number to connect to.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.TcpMonitorRequestAssertion']]:
        """
        A request can have multiple assertions.
        """
        return pulumi.get(self, "assertions")

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[_builtins.str]:
        """
        The data to send to the target host.
        """
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter(name="ipFamily")
    def ip_family(self) -> Optional[_builtins.str]:
        """
        The IP family to use when executing the TCP check. The value can be either `IPv4` or `IPv6`.
        """
        return pulumi.get(self, "ip_family")


@pulumi.output_type
class TcpMonitorRequestAssertion(dict):
    def __init__(__self__, *,
                 comparison: _builtins.str,
                 source: _builtins.str,
                 property: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None):
        """
        :param _builtins.str comparison: The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        :param _builtins.str source: The source of the asserted value. Possible values are `RESPONSE_DATA` and `RESPONSE_TIME`.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def comparison(self) -> _builtins.str:
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `HAS_KEY`, `NOT_HAS_KEY`, `HAS_VALUE`, `NOT_HAS_VALUE`, `IS_EMPTY`, `NOT_EMPTY`, `GREATER_THAN`, `LESS_THAN`, `CONTAINS`, `NOT_CONTAINS`, `IS_NULL`, and `NOT_NULL`.
        """
        return pulumi.get(self, "comparison")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The source of the asserted value. Possible values are `RESPONSE_DATA` and `RESPONSE_TIME`.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "property")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target")


@pulumi.output_type
class TcpMonitorRetryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBackoffSeconds":
            suggest = "base_backoff_seconds"
        elif key == "maxDurationSeconds":
            suggest = "max_duration_seconds"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "onlyOn":
            suggest = "only_on"
        elif key == "sameRegion":
            suggest = "same_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpMonitorRetryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpMonitorRetryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpMonitorRetryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 base_backoff_seconds: Optional[_builtins.int] = None,
                 max_duration_seconds: Optional[_builtins.int] = None,
                 max_retries: Optional[_builtins.int] = None,
                 only_on: Optional['outputs.TcpMonitorRetryStrategyOnlyOn'] = None,
                 same_region: Optional[_builtins.bool] = None):
        """
        :param _builtins.str type: Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        :param _builtins.int base_backoff_seconds: The number of seconds to wait before the first retry attempt. (Default `60`).
        :param _builtins.int max_duration_seconds: The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        :param _builtins.int max_retries: The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        :param 'TcpMonitorRetryStrategyOnlyOnArgs' only_on: Apply the retry strategy only if the defined conditions match.
        :param _builtins.bool same_region: Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        pulumi.set(__self__, "type", type)
        if base_backoff_seconds is not None:
            pulumi.set(__self__, "base_backoff_seconds", base_backoff_seconds)
        if max_duration_seconds is not None:
            pulumi.set(__self__, "max_duration_seconds", max_duration_seconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if only_on is not None:
            pulumi.set(__self__, "only_on", only_on)
        if same_region is not None:
            pulumi.set(__self__, "same_region", same_region)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="baseBackoffSeconds")
    def base_backoff_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait before the first retry attempt. (Default `60`).
        """
        return pulumi.get(self, "base_backoff_seconds")

    @_builtins.property
    @pulumi.getter(name="maxDurationSeconds")
    def max_duration_seconds(self) -> Optional[_builtins.int]:
        """
        The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        """
        return pulumi.get(self, "max_duration_seconds")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="onlyOn")
    def only_on(self) -> Optional['outputs.TcpMonitorRetryStrategyOnlyOn']:
        """
        Apply the retry strategy only if the defined conditions match.
        """
        return pulumi.get(self, "only_on")

    @_builtins.property
    @pulumi.getter(name="sameRegion")
    def same_region(self) -> Optional[_builtins.bool]:
        """
        Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        return pulumi.get(self, "same_region")


@pulumi.output_type
class TcpMonitorRetryStrategyOnlyOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkError":
            suggest = "network_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpMonitorRetryStrategyOnlyOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpMonitorRetryStrategyOnlyOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpMonitorRetryStrategyOnlyOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_error: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool network_error: When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        if network_error is not None:
            pulumi.set(__self__, "network_error", network_error)

    @_builtins.property
    @pulumi.getter(name="networkError")
    def network_error(self) -> Optional[_builtins.bool]:
        """
        When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        return pulumi.get(self, "network_error")


@pulumi.output_type
class TcpMonitorTriggerIncident(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifySubscribers":
            suggest = "notify_subscribers"
        elif key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpMonitorTriggerIncident. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpMonitorTriggerIncident.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpMonitorTriggerIncident.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 notify_subscribers: _builtins.bool,
                 service_id: _builtins.str,
                 severity: _builtins.str):
        """
        :param _builtins.str description: A detailed description of the incident.
        :param _builtins.str name: The name of the incident.
        :param _builtins.bool notify_subscribers: Whether to notify subscribers when the incident is triggered.
        :param _builtins.str service_id: The status page service that this incident will be associated with.
        :param _builtins.str severity: The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_subscribers", notify_subscribers)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A detailed description of the incident.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the incident.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifySubscribers")
    def notify_subscribers(self) -> _builtins.bool:
        """
        Whether to notify subscribers when the incident is triggered.
        """
        return pulumi.get(self, "notify_subscribers")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The status page service that this incident will be associated with.
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class UrlMonitorAlertChannelSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlMonitorAlertChannelSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlMonitorAlertChannelSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlMonitorAlertChannelSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activated: _builtins.bool,
                 channel_id: _builtins.int):
        """
        :param _builtins.bool activated: Whether an alert should be sent to this channel.
        :param _builtins.int channel_id: The ID of the alert channel.
        """
        pulumi.set(__self__, "activated", activated)
        pulumi.set(__self__, "channel_id", channel_id)

    @_builtins.property
    @pulumi.getter
    def activated(self) -> _builtins.bool:
        """
        Whether an alert should be sent to this channel.
        """
        return pulumi.get(self, "activated")

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> _builtins.int:
        """
        The ID of the alert channel.
        """
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class UrlMonitorAlertSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationType":
            suggest = "escalation_type"
        elif key == "parallelRunFailureThresholds":
            suggest = "parallel_run_failure_thresholds"
        elif key == "runBasedEscalations":
            suggest = "run_based_escalations"
        elif key == "timeBasedEscalations":
            suggest = "time_based_escalations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlMonitorAlertSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlMonitorAlertSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlMonitorAlertSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_type: _builtins.str,
                 parallel_run_failure_thresholds: Optional[Sequence['outputs.UrlMonitorAlertSettingsParallelRunFailureThreshold']] = None,
                 reminders: Optional[Sequence['outputs.UrlMonitorAlertSettingsReminder']] = None,
                 run_based_escalations: Optional[Sequence['outputs.UrlMonitorAlertSettingsRunBasedEscalation']] = None,
                 time_based_escalations: Optional[Sequence['outputs.UrlMonitorAlertSettingsTimeBasedEscalation']] = None):
        """
        :param _builtins.str escalation_type: Determines what type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`.
        :param Sequence['UrlMonitorAlertSettingsParallelRunFailureThresholdArgs'] parallel_run_failure_thresholds: Configuration for parallel run failure threshold.
        :param Sequence['UrlMonitorAlertSettingsReminderArgs'] reminders: Defines how often to send reminder notifications after initial alert.
        :param Sequence['UrlMonitorAlertSettingsRunBasedEscalationArgs'] run_based_escalations: Configuration for run-based escalation.
        :param Sequence['UrlMonitorAlertSettingsTimeBasedEscalationArgs'] time_based_escalations: Configuration for time-based escalation.
        """
        pulumi.set(__self__, "escalation_type", escalation_type)
        if parallel_run_failure_thresholds is not None:
            pulumi.set(__self__, "parallel_run_failure_thresholds", parallel_run_failure_thresholds)
        if reminders is not None:
            pulumi.set(__self__, "reminders", reminders)
        if run_based_escalations is not None:
            pulumi.set(__self__, "run_based_escalations", run_based_escalations)
        if time_based_escalations is not None:
            pulumi.set(__self__, "time_based_escalations", time_based_escalations)

    @_builtins.property
    @pulumi.getter(name="escalationType")
    def escalation_type(self) -> _builtins.str:
        """
        Determines what type of escalation to use. Possible values are `RUN_BASED` and `TIME_BASED`.
        """
        return pulumi.get(self, "escalation_type")

    @_builtins.property
    @pulumi.getter(name="parallelRunFailureThresholds")
    def parallel_run_failure_thresholds(self) -> Optional[Sequence['outputs.UrlMonitorAlertSettingsParallelRunFailureThreshold']]:
        """
        Configuration for parallel run failure threshold.
        """
        return pulumi.get(self, "parallel_run_failure_thresholds")

    @_builtins.property
    @pulumi.getter
    def reminders(self) -> Optional[Sequence['outputs.UrlMonitorAlertSettingsReminder']]:
        """
        Defines how often to send reminder notifications after initial alert.
        """
        return pulumi.get(self, "reminders")

    @_builtins.property
    @pulumi.getter(name="runBasedEscalations")
    def run_based_escalations(self) -> Optional[Sequence['outputs.UrlMonitorAlertSettingsRunBasedEscalation']]:
        """
        Configuration for run-based escalation.
        """
        return pulumi.get(self, "run_based_escalations")

    @_builtins.property
    @pulumi.getter(name="timeBasedEscalations")
    def time_based_escalations(self) -> Optional[Sequence['outputs.UrlMonitorAlertSettingsTimeBasedEscalation']]:
        """
        Configuration for time-based escalation.
        """
        return pulumi.get(self, "time_based_escalations")


@pulumi.output_type
class UrlMonitorAlertSettingsParallelRunFailureThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Whether parallel run failure threshold is enabled. Applicable only for monitors scheduled in parallel in multiple locations. (Default `false`).
        :param _builtins.int percentage: Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether parallel run failure threshold is enabled. Applicable only for monitors scheduled in parallel in multiple locations. (Default `false`).
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Percentage of runs that must fail to trigger alert. Possible values are `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, and `100`. (Default `10`).
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class UrlMonitorAlertSettingsReminder(dict):
    def __init__(__self__, *,
                 amount: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int amount: Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
        :param _builtins.int interval: Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.int]:
        """
        Number of reminder notifications to send. Possible values are `0`, `1`, `2`, `3`, `4`, `5`, and `100000` (`0` to disable, `100000` for unlimited). (Default `0`).
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Interval between reminder notifications in minutes. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class UrlMonitorAlertSettingsRunBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedRunThreshold":
            suggest = "failed_run_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlMonitorAlertSettingsRunBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlMonitorAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlMonitorAlertSettingsRunBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_run_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int failed_run_threshold: After how many failed consecutive check runs an alert notification should be sent. Possible values are between `1` and `5`. (Default `1`).
        """
        if failed_run_threshold is not None:
            pulumi.set(__self__, "failed_run_threshold", failed_run_threshold)

    @_builtins.property
    @pulumi.getter(name="failedRunThreshold")
    def failed_run_threshold(self) -> Optional[_builtins.int]:
        """
        After how many failed consecutive check runs an alert notification should be sent. Possible values are between `1` and `5`. (Default `1`).
        """
        return pulumi.get(self, "failed_run_threshold")


@pulumi.output_type
class UrlMonitorAlertSettingsTimeBasedEscalation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesFailingThreshold":
            suggest = "minutes_failing_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlMonitorAlertSettingsTimeBasedEscalation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlMonitorAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlMonitorAlertSettingsTimeBasedEscalation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_failing_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int minutes_failing_threshold: After how many minutes after a monitor starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        if minutes_failing_threshold is not None:
            pulumi.set(__self__, "minutes_failing_threshold", minutes_failing_threshold)

    @_builtins.property
    @pulumi.getter(name="minutesFailingThreshold")
    def minutes_failing_threshold(self) -> Optional[_builtins.int]:
        """
        After how many minutes after a monitor starts failing an alert should be sent. Possible values are `5`, `10`, `15`, and `30`. (Default `5`).
        """
        return pulumi.get(self, "minutes_failing_threshold")


@pulumi.output_type
class UrlMonitorRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "ipFamily":
            suggest = "ip_family"
        elif key == "skipSsl":
            suggest = "skip_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlMonitorRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlMonitorRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlMonitorRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 assertions: Optional[Sequence['outputs.UrlMonitorRequestAssertion']] = None,
                 follow_redirects: Optional[_builtins.bool] = None,
                 ip_family: Optional[_builtins.str] = None,
                 skip_ssl: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: The URL to monitor. Must be a valid HTTP or HTTPS URL.
        :param Sequence['UrlMonitorRequestAssertionArgs'] assertions: Assertions to validate the HTTP response. URL monitors only support status code assertions.
        :param _builtins.bool follow_redirects: Whether to follow HTTP redirects automatically. (Default `true`).
        :param _builtins.str ip_family: IP family version to use for the connection. The value can be either `IPv4` or `IPv6`. (Default `IPv4`).
        :param _builtins.bool skip_ssl: Whether to skip SSL certificate verification. (Default `false`).
        """
        pulumi.set(__self__, "url", url)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if ip_family is not None:
            pulumi.set(__self__, "ip_family", ip_family)
        if skip_ssl is not None:
            pulumi.set(__self__, "skip_ssl", skip_ssl)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL to monitor. Must be a valid HTTP or HTTPS URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.UrlMonitorRequestAssertion']]:
        """
        Assertions to validate the HTTP response. URL monitors only support status code assertions.
        """
        return pulumi.get(self, "assertions")

    @_builtins.property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[_builtins.bool]:
        """
        Whether to follow HTTP redirects automatically. (Default `true`).
        """
        return pulumi.get(self, "follow_redirects")

    @_builtins.property
    @pulumi.getter(name="ipFamily")
    def ip_family(self) -> Optional[_builtins.str]:
        """
        IP family version to use for the connection. The value can be either `IPv4` or `IPv6`. (Default `IPv4`).
        """
        return pulumi.get(self, "ip_family")

    @_builtins.property
    @pulumi.getter(name="skipSsl")
    def skip_ssl(self) -> Optional[_builtins.bool]:
        """
        Whether to skip SSL certificate verification. (Default `false`).
        """
        return pulumi.get(self, "skip_ssl")


@pulumi.output_type
class UrlMonitorRequestAssertion(dict):
    def __init__(__self__, *,
                 comparison: _builtins.str,
                 source: _builtins.str,
                 target: _builtins.str,
                 property: Optional[_builtins.str] = None):
        """
        :param _builtins.str comparison: The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `GREATER_THAN` and `LESS_THAN`.
        :param _builtins.str source: The source of the asserted value. The only allowed value is `STATUS_CODE`.
        :param _builtins.str target: The target value. Typically `200` when the source is `STATUS_CODE`.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @_builtins.property
    @pulumi.getter
    def comparison(self) -> _builtins.str:
        """
        The type of comparison to be executed between expected and actual value of the assertion. Possible values are `EQUALS`, `NOT_EQUALS`, `GREATER_THAN` and `LESS_THAN`.
        """
        return pulumi.get(self, "comparison")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The source of the asserted value. The only allowed value is `STATUS_CODE`.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The target value. Typically `200` when the source is `STATUS_CODE`.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "property")


@pulumi.output_type
class UrlMonitorRetryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBackoffSeconds":
            suggest = "base_backoff_seconds"
        elif key == "maxDurationSeconds":
            suggest = "max_duration_seconds"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "onlyOn":
            suggest = "only_on"
        elif key == "sameRegion":
            suggest = "same_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlMonitorRetryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlMonitorRetryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlMonitorRetryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 base_backoff_seconds: Optional[_builtins.int] = None,
                 max_duration_seconds: Optional[_builtins.int] = None,
                 max_retries: Optional[_builtins.int] = None,
                 only_on: Optional['outputs.UrlMonitorRetryStrategyOnlyOn'] = None,
                 same_region: Optional[_builtins.bool] = None):
        """
        :param _builtins.str type: Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        :param _builtins.int base_backoff_seconds: The number of seconds to wait before the first retry attempt. (Default `60`).
        :param _builtins.int max_duration_seconds: The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        :param _builtins.int max_retries: The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        :param 'UrlMonitorRetryStrategyOnlyOnArgs' only_on: Apply the retry strategy only if the defined conditions match.
        :param _builtins.bool same_region: Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        pulumi.set(__self__, "type", type)
        if base_backoff_seconds is not None:
            pulumi.set(__self__, "base_backoff_seconds", base_backoff_seconds)
        if max_duration_seconds is not None:
            pulumi.set(__self__, "max_duration_seconds", max_duration_seconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if only_on is not None:
            pulumi.set(__self__, "only_on", only_on)
        if same_region is not None:
            pulumi.set(__self__, "same_region", same_region)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Determines which type of retry strategy to use. Possible values are `FIXED`, `LINEAR`, `EXPONENTIAL`, `SINGLE_RETRY`, and `NO_RETRIES`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="baseBackoffSeconds")
    def base_backoff_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait before the first retry attempt. (Default `60`).
        """
        return pulumi.get(self, "base_backoff_seconds")

    @_builtins.property
    @pulumi.getter(name="maxDurationSeconds")
    def max_duration_seconds(self) -> Optional[_builtins.int]:
        """
        The total amount of time to continue retrying the check/monitor (maximum 600 seconds). Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `600`).
        """
        return pulumi.get(self, "max_duration_seconds")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        The maximum number of times to retry the check/monitor. Value must be between `1` and `10`. Available when `type` is `FIXED`, `LINEAR`, or `EXPONENTIAL`. (Default `2`).
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="onlyOn")
    def only_on(self) -> Optional['outputs.UrlMonitorRetryStrategyOnlyOn']:
        """
        Apply the retry strategy only if the defined conditions match.
        """
        return pulumi.get(self, "only_on")

    @_builtins.property
    @pulumi.getter(name="sameRegion")
    def same_region(self) -> Optional[_builtins.bool]:
        """
        Whether retries should be run in the same region as the initial check/monitor run. (Default `true`).
        """
        return pulumi.get(self, "same_region")


@pulumi.output_type
class UrlMonitorRetryStrategyOnlyOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkError":
            suggest = "network_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlMonitorRetryStrategyOnlyOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlMonitorRetryStrategyOnlyOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlMonitorRetryStrategyOnlyOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_error: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool network_error: When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        if network_error is not None:
            pulumi.set(__self__, "network_error", network_error)

    @_builtins.property
    @pulumi.getter(name="networkError")
    def network_error(self) -> Optional[_builtins.bool]:
        """
        When `true`, retry only if the cause of the failure is a network error. (Default `false`).
        """
        return pulumi.get(self, "network_error")


@pulumi.output_type
class UrlMonitorTriggerIncident(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifySubscribers":
            suggest = "notify_subscribers"
        elif key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlMonitorTriggerIncident. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlMonitorTriggerIncident.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlMonitorTriggerIncident.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 notify_subscribers: _builtins.bool,
                 service_id: _builtins.str,
                 severity: _builtins.str):
        """
        :param _builtins.str description: A detailed description of the incident.
        :param _builtins.str name: The name of the incident.
        :param _builtins.bool notify_subscribers: Whether to notify subscribers when the incident is triggered.
        :param _builtins.str service_id: The status page service that this incident will be associated with.
        :param _builtins.str severity: The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_subscribers", notify_subscribers)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A detailed description of the incident.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the incident.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifySubscribers")
    def notify_subscribers(self) -> _builtins.bool:
        """
        Whether to notify subscribers when the incident is triggered.
        """
        return pulumi.get(self, "notify_subscribers")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The status page service that this incident will be associated with.
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        The severity level of the incident. Possible values are `MINOR`, `MEDIUM`, `MAJOR`, and `CRITICAL`.
        """
        return pulumi.get(self, "severity")


